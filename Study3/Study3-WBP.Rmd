---
title: "Study 3 Well-being Prediction"
author: ""
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    df_print: paged
    highlight: tango
    theme: united
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: yes
  github_document:
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = FALSE,fig.path = "Study3/fig")
options(scipen=999)

```


```{r load packages, include=FALSE}
if (!require("pacman")) install.packages("pacman") #run this if you don't have pacman 
library(pacman)
set.seed(123)
pacman::p_load(tidyverse,rlang, plotrix, ggpubr, caret, broom, kableExtra, reactable, knitr, DT, stringr,ggwordcloud,Metrics,scales,rsample, purrr,psych, tibble,install = T) 

devtools::install_github("hadley/emo")
```

```{r eval=FALSE, include=FALSE}

install.packages("devtools")
devtools::install_version("text", version = "1.2.1", repos = "http://cran.us.r-project.org")

#### as of 8/29 need to exclusively use version 1.2.1 to get around a fatal R issue

library(text)
textrpp_install(prompt = F)
textrpp_initialize()
```

```{r}
plot_aes = theme_minimal() +
  theme(legend.position = "none",
        text = element_text(family = "Futura Medium"),
        axis.ticks.y = element_blank())
```

```{r define functions}
calculate_and_store_rmse <- function(column_name, model_names, actual_values, predicted_values) {
  results_list <- list()
  
  for (col_name in model_names) {
    if (grepl(column_name, col_name)) {
      rmse_value <- Metrics::rmse(actual_values[[column_name]], predicted_values[[col_name]])
      results_list <- c(results_list, list(data.frame(Model = col_name, RMSE = rmse_value)))
    }
  }
  
  return(results_list)
}

# Initialize an empty list to store results
results <- list()


table <- function(correlation_data) {
  # Convert the character columns to factors for better rendering
  correlation_data$descriptions <- gsub("^Q[0-9]+\\.\\.(.+?)\\.\\.Transcription", "\\1", correlation_data$descriptions)
  correlation_data$descriptions <- gsub("(\\d)_([A-Za-z])", "\\1~\\2", correlation_data$descriptions)
  correlation_data$descriptions <- as.factor(correlation_data$descriptions)
  correlation_data$alternative <- as.factor(correlation_data$alternative)

  # Round the numeric columns to three decimal places
  correlation_data$correlation <- round(as.numeric(correlation_data$correlation), 2)
  correlation_data$t_statistics <- round(as.numeric(correlation_data$t_statistics), 3)
  correlation_data$p_value <- sapply(correlation_data$p_value, function(p) {
    ifelse(as.numeric(p) < 0.001, "< .001", 
           ifelse(as.numeric(p) == 1, "1.000", 
                  gsub("0.(.*)", ".\\1", sprintf("%.3f", as.numeric(p)))))
  })
  
  # Apply similar formatting to the p_value_corrected column
  correlation_data$p_value_corrected <- sapply(correlation_data$p_value_corrected, function(p) {
    ifelse(as.numeric(p) < 0.001, "< .001", 
           ifelse(as.numeric(p) == 1, "1.000", 
                  gsub("0.(.*)", ".\\1", sprintf("%.3f", as.numeric(p)))))
  })

  # Add the RMSE column
  correlation_data$RMSE <- round(as.numeric(correlation_data$RMSE), 2)

  # Add the confidence interval (assuming you have 'conf_int_low' and 'conf_int_high' columns)
  correlation_data$confidence_interval <- paste0("[", 
                                                 round(as.numeric(correlation_data$conf_int_low), 2), 
                                                 ", ", 
                                                 round(as.numeric(correlation_data$conf_int_high), 2), 
                                                 "]")

  # Create the DataTable
  datatable(correlation_data, extensions = 'FixedColumns', 
            filter = list(position = 'top', clear = FALSE),
            options = list(search = list(regex = TRUE, caseInsensitive = FALSE), pageLength = 25))
}




```

```{r load-data}

data_dir="/Users/sm9518/Library/CloudStorage/Box-Box/LP2/well-being-prediction/"

#df <- read_csv("/Users/stevenmesquiti/Downloads/Prolific_wellbeing-prediction-text-long.csv")

df = read.csv(file.path(data_dir,"data/Prolific_wellbeing-prediction-text-long.csv"))

df = df %>% 
  rename_with(~ gsub("\\.", " ", .))

embeddings <- readRDS(file.path(data_dir,"embeddings/Study3-WBP-embeddings.rds"))
```

# Inter-item Correlations

```{r}

items = read.csv(file.path(data_dir,"data/Prolific_wellbeing-prediction-items.csv"))

items = items %>% 
  select(-X,pID)

calculate_cronbach_alpha <- function(df) {
  # Identify subscales based on column names
  subscales <- unique(sub("_[0-9]+$", "", colnames(df)))
  
  # Remove non-item columns
  subscales <- subscales[!subscales %in% c("pID", "survey_name")]
  
  # Initialize a dataframe to store alpha results
  alpha_results <- data.frame(subscale = character(), alpha = numeric(), stringsAsFactors = FALSE)
  
  # Loop through each subscale and calculate Cronbach's alpha
  for (subscale in subscales) {
    # Select columns for the current subscale
    subscale_cols <- grep(paste0("^", subscale, "_"), colnames(df), value = TRUE)
    
    if (length(subscale_cols) > 0) {
      # Calculate Cronbach's alpha
      alpha_value <- psych::alpha(df[, subscale_cols], check.keys = TRUE)$total$raw_alpha
      
      # Store the result in the dataframe
      alpha_results <- rbind(alpha_results, data.frame(subscale = subscale, alpha = alpha_value))
    }
  }
  
  # Calculate Cronbach's alpha for all PWB items excluding SWLS items
  # Select PWB columns
  pwb_cols <- grep("^PWB_", colnames(df), value = TRUE)
  
  # Select SWLS columns
  swls_cols <- grep("^SWLS_", colnames(df), value = TRUE)
  
  # Ensure there are columns to exclude
  if (length(pwb_cols) > 0 && length(swls_cols) > 0) {
    # Exclude SWLS columns from PWB columns
    pwb_excluding_swls_cols <- setdiff(pwb_cols, swls_cols)
    
    if (length(pwb_excluding_swls_cols) > 0) {
      pwb_alpha_value <- psych::alpha(df[, pwb_excluding_swls_cols], check.keys = TRUE)$total$raw_alpha
      
      # Add the result to the dataframe
      alpha_results <- rbind(alpha_results, data.frame(subscale = "PWB", alpha = pwb_alpha_value))
    }
  }
  
  return(alpha_results)
}


alpha_results <- calculate_cronbach_alpha(items)

pwb = items %>% 
  select(3:20)

pwb_alpha_value = psych::alpha(pwb)$total$raw_alpha
alpha_results <- rbind(alpha_results, data.frame(subscale = "PWB", alpha = pwb_alpha_value))


alpha_results %>% 
  mutate(alpha = round(alpha, 3)) %>% 
  reactable(striped = TRUE,
            filterable = TRUE,
            resizable = TRUE,
            pageSizeOptions = 25)

```

# Question 1

> Can language‑based assessments of participants’ well-being predict components of self-reported well-being? 

**Hypothesis:** Based on past research (e.g., Kjell et al., 2022), we hypothesize that linguistic analyses of participants’ written responses to open-ended questions about two components of well-being—life satisfaction and autonomy—will provide accurate predictions of self-reported ratings of these components. 

**Findings**:`r emo::ji("check")` Linguistic analyses of participants’ written responses to open-ended questions about two components of well-being—life satisfaction and autonomy— **do provide accurate predictions** of self-reported ratings of these components. 


## Satisfaction with Life {.tabset}

### Models {.tabset}

```{r}
rds_file_path <- file.path(data_dir, "models/Study3/SWLS_subscale.RDS") #update with the path to each model


if (!file.exists(rds_file_path)) {
  # If the RDS file does not exist, create the model
  SWLS_subscale <- textTrainLists(
    x = embeddings$texts$`SWLS-Text`, # Use satisfaction with life
    y = df[3:10], # Variables of interest are in columns 3-10
    force_train_method = "regression",
    save_output = "all",
    method_cor = "pearson",
    eval_measure = "rmse",
    p_adjust_method = "fdr",
    model_description = "SWLS embeddings Well-being, N = 285"
  )
  
  # Save the model output to an RDS file
  saveRDS(SWLS_subscale, rds_file_path)
} else {
  # If the RDS file already exists, load the data from it
  SWLS_subscale <- readRDS(rds_file_path)
}


filtered_predictions <- na.omit(SWLS_subscale$predictions[1:8])
SWLS_subscale_predictions <- as.data.frame(filtered_predictions)
models <- c(colnames(SWLS_subscale$predictions[1:8]))


###prep the data to calculate RMSE values 

data = df %>% 
  select(3:10) 



results = list()
column_names = colnames(data)
for (column_name in column_names) {
  result <- calculate_and_store_rmse(
    column_name = column_name,
    model_names = models,
    actual_values = data,
    predicted_values = SWLS_subscale_predictions
  )
  results <- c(results, result)
  # Convert the results list to a data frame
SWLS_rmse <- results %>%
  bind_rows() %>%
  distinct()
}

# Associate RMSE with subscale results
SWLS_subscale_results <- head(SWLS_subscale$results, 8)
SWLS_subscale_results$RMSE <- SWLS_rmse$RMSE


###extract information for heatmap
SWLS_subscale_results <- 
  SWLS_subscale_results %>%
  mutate(
    prompt = ifelse(grepl("SWLS", descriptions), "SWLS", NA),
    outcome = ifelse(grepl("embeddings\\$texts\\$`SWLS-Text`_", descriptions), 
                     gsub(".*`SWLS-Text`_", "", descriptions),
                     NA))

table(SWLS_subscale_results)

saveRDS(SWLS_subscale_results,file.path(data_dir,"models/Study3/SWLS_subscale_results.RDS"))
```

```{r SWLS-heat}

SWLS_subscale_results <- SWLS_subscale_results %>%
  mutate(
    correlation = as.numeric(correlation),
    df = as.numeric(df),
    p_value = as.numeric(p_value),
    p_value_corrected = as.numeric(p_value_corrected),
    t_statistics = as.numeric(t_statistics)
  )


SWLS_heat =  ggplot(SWLS_subscale_results, aes(x = prompt, y = outcome, fill = correlation)) +
  geom_tile(color = "white") +
  geom_text(aes(label = round(correlation, 3)), color = "black", size = 4) +
  geom_text(aes(label = sprintf("(%s)", round(RMSE, 3))), color = "black", size = 3, vjust = 2) +  # Add RMSE values

  scale_fill_gradient2(low = "dodgerblue",
                       mid = "#FFFFCC",
                       high = "#c44536") +
    geom_text(data = subset(SWLS_subscale_results, p_value_corrected < 0.05), aes(label = "*", x = prompt, y = outcome, hjust = 1),
              color = "black", size = 4, vjust = -0.5) +
    geom_text(data = subset(SWLS_subscale_results, p_value_corrected < 0.01), aes(label = "**", x = prompt, y = outcome, hjust = 1),
              color = "black", size = 4, vjust = -0.5) +
    geom_text(data = subset(SWLS_subscale_results, p_value_corrected < 0.001), aes(label = "***", x = prompt, y = outcome, hjust = 1),
              color = "black", size = 4, vjust = -0.5) + plot_aes

SWLS_heat
```


## Autonomy {.tabset}

### Models

```{r}
rds_file_path_autonomy <- file.path(data_dir, "models/Study3/autonomy_subscale.RDS")

# Check if the RDS file exists
if (!file.exists(rds_file_path_autonomy)) {
  # If the RDS file does not exist, create the model
  Autonomy_subscale <- textTrainLists(
    x = embeddings$texts$`Autonomy-Text`, # Use autonomy text
    y = df[3:10], # Variables of interest are in columns 3-10
    force_train_method = "regression",
    save_output = "all",
    method_cor = "pearson",
    eval_measure = "rmse",
    p_adjust_method = "fdr",
    model_description = "Autonomy embeddings well-being, N = 285"
  )
  
  # Save the model output to an RDS file
  saveRDS(Autonomy_subscale, rds_file_path_autonomy)
} else {
  # If the RDS file already exists, load the data from it
  Autonomy_subscale <- readRDS(rds_file_path_autonomy)
}

filtered_predictions <- na.omit(Autonomy_subscale$predictions[1:8])
Autonomy_subscale_predictions <- as.data.frame(filtered_predictions)
models <- c(colnames(Autonomy_subscale$predictions[1:8]))

results = list()
column_names = colnames(data)
for (column_name in column_names) {
  result <- calculate_and_store_rmse(
    column_name = column_name,
    model_names = models,
    actual_values = data,
    predicted_values = Autonomy_subscale_predictions
  )
  results <- c(results, result)
  # Convert the results list to a data frame
Autonomy_rmse <- results %>%
  bind_rows() %>%
  distinct()
}

# Associate RMSE with subscale results
Autonomy_subscale_results <- head(Autonomy_subscale$results, 8)
Autonomy_subscale_results$RMSE <- Autonomy_rmse$RMSE




Autonomy_subscale_results <- 
  Autonomy_subscale_results %>%
  mutate(
    prompt = ifelse(grepl("Autonomy-", descriptions), "Autonomy", NA),
    outcome = ifelse(grepl("embeddings\\$texts\\$`Autonomy-Text`_", descriptions), 
                     gsub(".*`Autonomy-Text`_", "", descriptions),
                     NA)
  )
table(Autonomy_subscale_results)

saveRDS(Autonomy_subscale_results,file.path(data_dir,"models/Study3/Autonomy_subscale_results.RDS"))

```

### Heatmaps 

```{r Autonomy-heat}
Autonomy_subscale_results <- Autonomy_subscale_results %>%
  mutate(
    correlation = as.numeric(correlation),
    df = as.numeric(df),
    p_value = as.numeric(p_value),
    p_value_corrected = as.numeric(p_value_corrected),
    t_statistics = as.numeric(t_statistics)
  )


Autonomy_heat =  ggplot(Autonomy_subscale_results, aes(x = prompt, y = outcome, fill = correlation)) +
  geom_tile(color = "white") +
  geom_text(aes(label = round(correlation, 3)), color = "black", size = 4) +
  geom_text(aes(label = sprintf("(%s)", round(RMSE, 3))), color = "black", size = 3, vjust = 2) +  # Add RMSE values

  scale_fill_gradient2(low = "dodgerblue",
                       mid = "#FFFFCC",
                       high = "#c44536") +
    geom_text(data = subset(Autonomy_subscale_results, p_value_corrected < 0.05), aes(label = "*", x = prompt, y = outcome, hjust = 1),
              color = "black", size = 4, vjust = -0.5) +
    geom_text(data = subset(Autonomy_subscale_results, p_value_corrected < 0.01), aes(label = "**", x = prompt, y = outcome, hjust = 1),
              color = "black", size = 4, vjust = -0.5) +
    geom_text(data = subset(Autonomy_subscale_results, p_value_corrected < 0.001), aes(label = "***", x = prompt, y = outcome, hjust = 1),
              color = "black", size = 4, vjust = -0.5) + plot_aes

Autonomy_heat
```


## All heatmaps (all data)

```{r all-heat}
all_heat = ggarrange(Autonomy_heat, SWLS_heat, ncol = 2,nrow = 1, common.legend = T)

all_heat +
  ggtitle("Subscale Predictions") +

  plot_aes  +  
  theme(
    plot.title = element_text(hjust = 0.5, vjust = 1.5),
    plot.caption = element_text(hjust = 1, size = 10)
  ) 
```

```{r}
# extract confidence intervals for each model

process_results <- function(result_list) {
  results <- data.frame(
    model = character(),
    statistic = numeric(),
    parameter = integer(),
    p.value = numeric(),
    r = numeric(),
    null.value = numeric(),
    alternative = character(),
    method = character(),
    data.name = character(),
    conf.int_low = numeric(),
    conf.int_high = numeric(),
    stringsAsFactors = FALSE
  )
  
  for (model_name in names(result_list)) {
    # Extract the relevant information from the current data frame
    current_result <- result_list[[model_name]]
    
    # Check if current_result contains all necessary elements
    if (!is.null(current_result) && length(current_result) > 0) {
      
      # Ensure that fields exist and are non-empty; otherwise, fill with NA
      result_df <- data.frame(
        model = model_name,
        statistic = if (!is.null(current_result$statistic)) current_result$statistic else NA,
        parameter = if (!is.null(current_result$parameter)) current_result$parameter else NA,
        p.value = if (!is.null(current_result$p.value)) current_result$p.value else NA,
        r = if (!is.null(current_result$estimate)) current_result$estimate else NA,
        null.value = if (!is.null(current_result$null.value)) current_result$null.value else NA,
        alternative = if (!is.null(current_result$alternative)) current_result$alternative else NA,
        method = if (!is.null(current_result$method)) current_result$method else NA,
        data.name = if (!is.null(current_result$data.name)) current_result$data.name else NA,
        conf.int_low = if (!is.null(current_result$conf.int)) current_result$conf.int[1] else NA,
        conf.int_high = if (!is.null(current_result$conf.int)) current_result$conf.int[2] else NA,
        stringsAsFactors = FALSE
      )
      
      # Add the data frame to results
      results <- rbind(results, result_df)
    } else {
      message(paste("Skipping model:", model_name, "due to missing or empty result."))
    }
  }
  
  return(results)
}



result_list <- list(
  autonomy_acceptance_sub = Autonomy_subscale$all_output$`embeddings$texts$\`Autonomy-Text\`_PWB self_acceptance`$results,
  autonomy_autonomy_sub = Autonomy_subscale$all_output$`embeddings$texts$\`Autonomy-Text\`_PWB autonomy`$results,
  autonomy_growth_sub = Autonomy_subscale$all_output$`embeddings$texts$\`Autonomy-Text\`_PWB personal_growth`$results,
  autonomy_purpose_sub = Autonomy_subscale$all_output$`embeddings$texts$\`Autonomy-Text\`_PWB purpose`$results,
  autonomy_relationships_sub = Autonomy_subscale$all_output$`embeddings$texts$\`Autonomy-Text\`_PWB positive_relations`$results,
  autonomy_PWB_sub = Autonomy_subscale$all_output$`embeddings$texts$\`Autonomy-Text\`_PWB mean`$results,
  autonomy_SWLS_sub = Autonomy_subscale$all_output$`embeddings$texts$\`Autonomy-Text\`_SWLS mean`$results
)

autonomy_results <- process_results(result_list)


autonomy_results<- 
  autonomy_results %>%
  mutate(
    prompt = ifelse(grepl("autonomy_", model), "autonomy", NA),
    outcome = ifelse(grepl("_sub", model), gsub(".*autonomy_", "", gsub("_sub", "", model)), NA))


#### SWLS

result_list <- list(
  SWLS_acceptance_sub = SWLS_subscale$all_output$`embeddings$texts$\`SWLS-Text\`_PWB self_acceptance`$results,
  SWLS_autonomy_sub = SWLS_subscale$all_output$`embeddings$texts$\`SWLS-Text\`_PWB autonomy`$results,
  SWLS_growth_sub = SWLS_subscale$all_output$`embeddings$texts$\`SWLS-Text\`_PWB personal_growth`$results,
  SWLS_purpose_sub = SWLS_subscale$all_output$`embeddings$texts$\`SWLS-Text\`_PWB purpose`$results,
  SWLS_relationships_sub = SWLS_subscale$all_output$`embeddings$texts$\`SWLS-Text\`_PWB positive_relations`$results,
  SWLS_PWB_sub = SWLS_subscale$all_output$`embeddings$texts$\`SWLS-Text\`_PWB mean`$results,
  SWLS_SWLS_sub = SWLS_subscale$all_output$`embeddings$texts$\`SWLS-Text\`_SWLS mean`$results
)

SWLS_results <- process_results(result_list)


SWLS_results<- 
  SWLS_results %>%
  mutate(
    prompt = ifelse(grepl("SWLS_", model), "SWLS", NA),
    outcome = ifelse(grepl("_sub", model), gsub(".*SWLS_", "", gsub("_sub", "", model)), NA))


### bind 

all_effects = rbind(autonomy_results,SWLS_results)

saveRDS(all_effects,file.path(data_dir,"models/prelim-analyses/study3_all_effects.RDS"))


```



# Question 2 

```{r bootstrapping function}
# Function to calculate correlation in a bootstrap sample
corr_on_bootstrap <- function(split) {
  cor(analysis(split)[[1]], analysis(split)[[2]])
}
```

> To what degree can language‑based assessments of participants’ well-being generalize to other components (e.g., psychological well-being, life satisfaction) of well-being? 

**Hypothesis:**  Based on the past literature (e.g., Gallagher et al., 2009), which has found that the components that support the structure of hedonic and eudaimonic well-being are correlated, we predict that language‑based assessments of participants’ well-being should generalize to other components of well-being (e.g., Satisfaction with Life and Psychological Well-being). However, language assessments should be able to differentiate between components (e.g., the measure should have noticeably lower correlations with measures from which it theoretically differs).

**Findings:** `r emo::ji("check")` Results showed that language‑based assessments of participants’ well-being should generalize to other components of well-being.

`r emo::ji("x")` However, we failed to see consistent evidence that language‑based assessments of participants’ well-being could differentiate between components with which they theoretically differed.


```{r}
# Load predictions for both models
model1_predictions = SWLS_subscale
model2_predictions = SWLS_subscale
```

# Can SWL language assessments can differentiate SWL from... {.tabset}

**Notes**

> The orange distrubtions represent 95% of the distribution. if the distribution crosses zero, there is not sufficient evidence that that the language assessment of well-being can differentiate between the two components of well-being.


## Psychological Well-being

```{r}
# Extract actual values and predictions for both models
y_model1 <- df$`SWLS mean`
yhat_model1 <- model1_predictions$predictions$`embeddings$texts$\`SWLS-Text\`_SWLS mean_pred`
y_model2 <- df$`PWB mean`
yhat_model2 <- model2_predictions$predictions$`embeddings$texts$\`SWLS-Text\`_PWB mean_pred`

# Create data frame for Model 1
model1_df <- tibble::tibble(y_model1, yhat_model1)

# Break the association by shuffling the predicted values
model1_df_shuffled <- model1_df %>% mutate(yhat_model1 = sample(yhat_model1))

# Perform bootstrapping on the shuffled data
model1_boots_shuffled <- rsample::bootstraps(model1_df_shuffled, times = 10000, apparent = FALSE)
model1_boot_corrs_shuffled <- model1_boots_shuffled %>%
  mutate(corr_model1 = map(splits, corr_on_bootstrap))

model1_boot_distribution_shuffled <- model1_boot_corrs_shuffled %>%
  unnest(corr_model1) %>%
  select(corr_model1)

# Create data frame for Model 2
model2_df <- tibble::tibble(y_model2, yhat_model2)

# Break the association by shuffling the predicted values
model2_df_shuffled <- model2_df %>% mutate(yhat_model2 = sample(yhat_model2))

# Perform bootstrapping on the shuffled data
model2_boots_shuffled <- rsample::bootstraps(model2_df_shuffled, times = 10000, apparent = FALSE)
model2_boot_corrs_shuffled <- model2_boots_shuffled %>%
  mutate(corr_model2 = map(splits, corr_on_bootstrap))
model2_boot_distribution_shuffled <- model2_boot_corrs_shuffled %>%
  unnest(corr_model2) %>%
  select(corr_model2)

# Combine the distributions
comparison_df_shuffled <- tibble::tibble(
  correlation_difference = model1_boot_distribution_shuffled$corr_model1 -  model2_boot_distribution_shuffled$corr_model2
)

# Calculate percentage of absolute differences greater than zero
percentage_greater_than_zero_shuffled <- mean(comparison_df_shuffled$correlation_difference > 0) * 100
p_value <- (100 - percentage_greater_than_zero_shuffled) / 100

```

```{r}
# Calculate the quantiles
lower_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.025)
upper_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.975)

# Calculate the mean difference for the vertical line
mean_diff <- mean(comparison_df_shuffled$correlation_difference)

# Create the plot
ggplot(comparison_df_shuffled, aes(x = correlation_difference)) +
  geom_density(color = "black", fill = "skyblue", alpha = 0.2) +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 0.5) +
  geom_ribbon(stat = "density", aes(ymin = 0, ymax = ..density..), 
              fill = "orange", alpha = 0.7, 
              data = comparison_df_shuffled[comparison_df_shuffled$correlation_difference >= lower_bound & comparison_df_shuffled$correlation_difference <= upper_bound, ]) +
  labs(title = "Distribution of Correlation Differences",
       x = "Correlation Difference",
       y = "Density") +
  annotate("text", x = Inf, y = Inf, label = paste0("% greater than zero: ", round(percentage_greater_than_zero_shuffled, 2), "%"),
           hjust = 1.1, vjust = 1.1, size = 5, color = "black") +
  plot_aes
```

> Satisfaction with life responses can  distinguish Satisfaction with Life scores from Psychological Well-being scores (r = 0.624 verus 0.403, bootstrapped **p** = `r p_value`)

## Autonomy

```{r}
# Extract actual values and predictions for both models
y_model1 <- df$`SWLS mean`
yhat_model1 <- model1_predictions$predictions$`embeddings$texts$\`SWLS-Text\`_SWLS mean_pred`
y_model2 <- df$`PWB autonomy`
yhat_model2 <- model2_predictions$predictions$`embeddings$texts$\`SWLS-Text\`_PWB autonomy_pred`

# Create data frame for Model 1
model1_df <- tibble::tibble(y_model1, yhat_model1)

# Break the association by shuffling the predicted values
model1_df_shuffled <- model1_df %>% mutate(yhat_model1 = sample(yhat_model1))

# Perform bootstrapping on the shuffled data
model1_boots_shuffled <- rsample::bootstraps(model1_df_shuffled, times = 10000, apparent = FALSE)
model1_boot_corrs_shuffled <- model1_boots_shuffled %>%
  mutate(corr_model1 = map(splits, corr_on_bootstrap))

model1_boot_distribution_shuffled <- model1_boot_corrs_shuffled %>%
  unnest(corr_model1) %>%
  select(corr_model1)

# Create data frame for Model 2
model2_df <- tibble::tibble(y_model2, yhat_model2)

# Break the association by shuffling the predicted values
model2_df_shuffled <- model2_df %>% mutate(yhat_model2 = sample(yhat_model2))

# Perform bootstrapping on the shuffled data
model2_boots_shuffled <- rsample::bootstraps(model2_df_shuffled, times = 10000, apparent = FALSE)
model2_boot_corrs_shuffled <- model2_boots_shuffled %>%
  mutate(corr_model2 = map(splits, corr_on_bootstrap))
model2_boot_distribution_shuffled <- model2_boot_corrs_shuffled %>%
  unnest(corr_model2) %>%
  select(corr_model2)

# Combine the distributions
comparison_df_shuffled <- tibble::tibble(
  correlation_difference = model1_boot_distribution_shuffled$corr_model1 - model2_boot_distribution_shuffled$corr_model2
)

# Calculate percentage of absolute differences greater than zero
percentage_greater_than_zero_shuffled <- mean(comparison_df_shuffled$correlation_difference > 0) * 100
p_value <- (100 - percentage_greater_than_zero_shuffled) / 100
```



```{r}
# Calculate the quantiles
lower_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.025)
upper_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.975)

# Calculate the mean difference for the vertical line
mean_diff <- mean(comparison_df_shuffled$correlation_difference)

# Create the plot
ggplot(comparison_df_shuffled, aes(x = correlation_difference)) +
  geom_density(color = "black", fill = "skyblue", alpha = 0.2) +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 0.5) +
  geom_ribbon(stat = "density", aes(ymin = 0, ymax = ..density..), 
              fill = "orange", alpha = 0.7, 
              data = comparison_df_shuffled[comparison_df_shuffled$correlation_difference >= lower_bound & comparison_df_shuffled$correlation_difference <= upper_bound, ]) +
  labs(title = "Distribution of Correlation Differences",
       x = "Correlation Difference",
       y = "Density") +
  annotate("text", x = Inf, y = Inf, label = paste0("% greater than zero: ", round(percentage_greater_than_zero_shuffled, 2), "%"),
           hjust = 1.1, vjust = 1.1, size = 5, color = "black") +
  plot_aes
```

> SWLS responses cannot differentiate between Satisfaction with life and autonomy responses (r = 0.624 verus 0.131, bootstrapped **p**  = `r p_value`)

## Personal Growth 

```{r}
# Extract actual values and predictions for both models
y_model1 <- df$`SWLS mean`
yhat_model1 <- model1_predictions$predictions$`embeddings$texts$\`SWLS-Text\`_SWLS mean_pred`
y_model2 <- df$`PWB personal_growth`
yhat_model2 <- model2_predictions$predictions$`embeddings$texts$\`SWLS-Text\`_PWB personal_growth_pred`

# Create data frame for Model 1
model1_df <- tibble::tibble(y_model1, yhat_model1)

# Break the association by shuffling the predicted values
model1_df_shuffled <- model1_df %>% mutate(yhat_model1 = sample(yhat_model1))

# Perform bootstrapping on the shuffled data
model1_boots_shuffled <- rsample::bootstraps(model1_df_shuffled, times = 10000, apparent = FALSE)
model1_boot_corrs_shuffled <- model1_boots_shuffled %>%
  mutate(corr_model1 = map(splits, corr_on_bootstrap))

model1_boot_distribution_shuffled <- model1_boot_corrs_shuffled %>%
  unnest(corr_model1) %>%
  select(corr_model1)

# Create data frame for Model 2
model2_df <- tibble::tibble(y_model2, yhat_model2)

# Break the association by shuffling the predicted values
model2_df_shuffled <- model2_df %>% mutate(yhat_model2 = sample(yhat_model2))

# Perform bootstrapping on the shuffled data
model2_boots_shuffled <- rsample::bootstraps(model2_df_shuffled, times = 10000, apparent = FALSE)
model2_boot_corrs_shuffled <- model2_boots_shuffled %>%
  mutate(corr_model2 = map(splits, corr_on_bootstrap))
model2_boot_distribution_shuffled <- model2_boot_corrs_shuffled %>%
  unnest(corr_model2) %>%
  select(corr_model2)

# Combine the distributions
comparison_df_shuffled <- tibble::tibble(
  correlation_difference = model1_boot_distribution_shuffled$corr_model1 - model2_boot_distribution_shuffled$corr_model2
)

# Calculate percentage of absolute differences greater than zero
percentage_greater_than_zero_shuffled <- mean(comparison_df_shuffled$correlation_difference > 0) * 100
p_value <- (100 - percentage_greater_than_zero_shuffled) / 100
```



```{r}
# Calculate the quantiles
lower_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.025)
upper_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.975)

# Calculate the mean difference for the vertical line
mean_diff <- mean(comparison_df_shuffled$correlation_difference)

# Create the plot
ggplot(comparison_df_shuffled, aes(x = correlation_difference)) +
  geom_density(color = "black", fill = "skyblue", alpha = 0.2) +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 0.5) +
  geom_ribbon(stat = "density", aes(ymin = 0, ymax = ..density..), 
              fill = "orange", alpha = 0.7, 
              data = comparison_df_shuffled[comparison_df_shuffled$correlation_difference >= lower_bound & comparison_df_shuffled$correlation_difference <= upper_bound, ]) +
  labs(title = "Distribution of Correlation Differences",
       x = "Correlation Difference",
       y = "Density") +
  annotate("text", x = Inf, y = Inf, label = paste0("% greater than zero: ", round(percentage_greater_than_zero_shuffled, 2), "%"),
           hjust = 1.1, vjust = 1.1, size = 5, color = "black") +
  plot_aes
```

> SWLS responses cannot differentiate between Satisfaction with life and personal growth responses (r = 0.624 verus 0.117, bootstrapped **p** = `r p_value`) 

## Positive Relationships 

```{r}
# Extract actual values and predictions for both models
y_model1 <- df$`SWLS mean`
yhat_model1 <- model1_predictions$predictions$`embeddings$texts$\`SWLS-Text\`_SWLS mean_pred`
y_model2 <- df$`PWB positive_relations`
yhat_model2 <- model2_predictions$predictions$`embeddings$texts$\`SWLS-Text\`_PWB positive_relations_pred`

# Create data frame for Model 1
model1_df <- tibble::tibble(y_model1, yhat_model1)

# Break the association by shuffling the predicted values
model1_df_shuffled <- model1_df %>% mutate(yhat_model1 = sample(yhat_model1))

# Perform bootstrapping on the shuffled data
model1_boots_shuffled <- rsample::bootstraps(model1_df_shuffled, times = 10000, apparent = FALSE)
model1_boot_corrs_shuffled <- model1_boots_shuffled %>%
  mutate(corr_model1 = map(splits, corr_on_bootstrap))

model1_boot_distribution_shuffled <- model1_boot_corrs_shuffled %>%
  unnest(corr_model1) %>%
  select(corr_model1)

# Create data frame for Model 2
model2_df <- tibble::tibble(y_model2, yhat_model2)

# Break the association by shuffling the predicted values
model2_df_shuffled <- model2_df %>% mutate(yhat_model2 = sample(yhat_model2))

# Perform bootstrapping on the shuffled data
model2_boots_shuffled <- rsample::bootstraps(model2_df_shuffled, times = 10000, apparent = FALSE)
model2_boot_corrs_shuffled <- model2_boots_shuffled %>%
  mutate(corr_model2 = map(splits, corr_on_bootstrap))
model2_boot_distribution_shuffled <- model2_boot_corrs_shuffled %>%
  unnest(corr_model2) %>%
  select(corr_model2)

# Combine the distributions
comparison_df_shuffled <- tibble::tibble(
  correlation_difference = model1_boot_distribution_shuffled$corr_model1 - model2_boot_distribution_shuffled$corr_model2
)

# Calculate percentage of absolute differences greater than zero
percentage_greater_than_zero_shuffled <- mean(comparison_df_shuffled$correlation_difference > 0) * 100
p_value <- (100 - percentage_greater_than_zero_shuffled) / 100
```



```{r}
# Calculate the quantiles
lower_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.025)
upper_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.975)

# Calculate the mean difference for the vertical line
mean_diff <- mean(comparison_df_shuffled$correlation_difference)

# Create the plot
ggplot(comparison_df_shuffled, aes(x = correlation_difference)) +
  geom_density(color = "black", fill = "skyblue", alpha = 0.2) +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 0.5) +
  geom_ribbon(stat = "density", aes(ymin = 0, ymax = ..density..), 
              fill = "orange", alpha = 0.7, 
              data = comparison_df_shuffled[comparison_df_shuffled$correlation_difference >= lower_bound & comparison_df_shuffled$correlation_difference <= upper_bound, ]) +
  labs(title = "Distribution of Correlation Differences",
       x = "Correlation Difference",
       y = "Density") +
  annotate("text", x = Inf, y = Inf, label = paste0("% greater than zero: ", round(percentage_greater_than_zero_shuffled, 2), "%"),
           hjust = 1.1, vjust = 1.1, size = 5, color = "black") +
  plot_aes
```

> SWLS responses cannot differentiate between Satisfaction with life and positive relationship responses (r = 0.624 verus 0.153, bootstrapped **p** = `r p_value`)

## Purpose

```{r}
# Extract actual values and predictions for both models
y_model1 <- df$`SWLS mean`
yhat_model1 <- model1_predictions$predictions$`embeddings$texts$\`SWLS-Text\`_SWLS mean_pred`
y_model2 <- df$`PWB purpose`
yhat_model2 <- model2_predictions$predictions$`embeddings$texts$\`SWLS-Text\`_PWB purpose_pred`

# Create data frame for Model 1
model1_df <- tibble::tibble(y_model1, yhat_model1)

# Break the association by shuffling the predicted values
model1_df_shuffled <- model1_df %>% mutate(yhat_model1 = sample(yhat_model1))

# Perform bootstrapping on the shuffled data
model1_boots_shuffled <- rsample::bootstraps(model1_df_shuffled, times = 10000, apparent = FALSE)
model1_boot_corrs_shuffled <- model1_boots_shuffled %>%
  mutate(corr_model1 = map(splits, corr_on_bootstrap))

model1_boot_distribution_shuffled <- model1_boot_corrs_shuffled %>%
  unnest(corr_model1) %>%
  select(corr_model1)

# Create data frame for Model 2
model2_df <- tibble::tibble(y_model2, yhat_model2)

# Break the association by shuffling the predicted values
model2_df_shuffled <- model2_df %>% mutate(yhat_model2 = sample(yhat_model2))

# Perform bootstrapping on the shuffled data
model2_boots_shuffled <- rsample::bootstraps(model2_df_shuffled, times = 10000, apparent = FALSE)
model2_boot_corrs_shuffled <- model2_boots_shuffled %>%
  mutate(corr_model2 = map(splits, corr_on_bootstrap))
model2_boot_distribution_shuffled <- model2_boot_corrs_shuffled %>%
  unnest(corr_model2) %>%
  select(corr_model2)

# Combine the distributions
comparison_df_shuffled <- tibble::tibble(
  correlation_difference = model1_boot_distribution_shuffled$corr_model1 - model2_boot_distribution_shuffled$corr_model2
)

# Calculate percentage of absolute differences greater than zero
percentage_greater_than_zero_shuffled <- mean(comparison_df_shuffled$correlation_difference > 0) * 100
p_value <- (100 - percentage_greater_than_zero_shuffled) / 100
```



```{r}
# Calculate the quantiles
lower_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.025)
upper_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.975)

# Calculate the mean difference for the vertical line
mean_diff <- mean(comparison_df_shuffled$correlation_difference)

# Create the plot
ggplot(comparison_df_shuffled, aes(x = correlation_difference)) +
  geom_density(color = "black", fill = "skyblue", alpha = 0.2) +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 0.5) +
  geom_ribbon(stat = "density", aes(ymin = 0, ymax = ..density..), 
              fill = "orange", alpha = 0.7, 
              data = comparison_df_shuffled[comparison_df_shuffled$correlation_difference >= lower_bound & comparison_df_shuffled$correlation_difference <= upper_bound, ]) +
  labs(title = "Distribution of Correlation Differences",
       x = "Correlation Difference",
       y = "Density") +
  annotate("text", x = Inf, y = Inf, label = paste0("% greater than zero: ", round(percentage_greater_than_zero_shuffled, 2), "%"),
           hjust = 1.1, vjust = 1.1, size = 5, color = "black") +
  plot_aes
```

> SWLS responses cannot differentiate between Satisfaction with life and purpose in life (r = 0.624 verus 0.224, bootstrapped **p** = `r p_value`)

## Self-Acceptance

```{r}
# Extract actual values and predictions for both models
y_model1 <- df$`SWLS mean`
yhat_model1 <- model1_predictions$predictions$`embeddings$texts$\`SWLS-Text\`_SWLS mean_pred`
y_model2 <- df$`PWB self_acceptance`
yhat_model2 <- model2_predictions$predictions$`embeddings$texts$\`SWLS-Text\`_PWB self_acceptance_pred`

# Create data frame for Model 1
model1_df <- tibble::tibble(y_model1, yhat_model1)

# Break the association by shuffling the predicted values
model1_df_shuffled <- model1_df %>% mutate(yhat_model1 = sample(yhat_model1))

# Perform bootstrapping on the shuffled data
model1_boots_shuffled <- rsample::bootstraps(model1_df_shuffled, times = 10000, apparent = FALSE)
model1_boot_corrs_shuffled <- model1_boots_shuffled %>%
  mutate(corr_model1 = map(splits, corr_on_bootstrap))

model1_boot_distribution_shuffled <- model1_boot_corrs_shuffled %>%
  unnest(corr_model1) %>%
  select(corr_model1)

# Create data frame for Model 2
model2_df <- tibble::tibble(y_model2, yhat_model2)

# Break the association by shuffling the predicted values
model2_df_shuffled <- model2_df %>% mutate(yhat_model2 = sample(yhat_model2))

# Perform bootstrapping on the shuffled data
model2_boots_shuffled <- rsample::bootstraps(model2_df_shuffled, times = 10000, apparent = FALSE)
model2_boot_corrs_shuffled <- model2_boots_shuffled %>%
  mutate(corr_model2 = map(splits, corr_on_bootstrap))
model2_boot_distribution_shuffled <- model2_boot_corrs_shuffled %>%
  unnest(corr_model2) %>%
  select(corr_model2)

# Combine the distributions
comparison_df_shuffled <- tibble::tibble(
  correlation_difference = model1_boot_distribution_shuffled$corr_model1 - model2_boot_distribution_shuffled$corr_model2
)

# Calculate percentage of absolute differences greater than zero
percentage_greater_than_zero_shuffled <- mean(comparison_df_shuffled$correlation_difference > 0) * 100
p_value <- (100 - percentage_greater_than_zero_shuffled) / 100
```



```{r}
# Calculate the quantiles
lower_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.025)
upper_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.975)

# Calculate the mean difference for the vertical line
mean_diff <- mean(comparison_df_shuffled$correlation_difference)

# Create the plot
ggplot(comparison_df_shuffled, aes(x = correlation_difference)) +
  geom_density(color = "black", fill = "skyblue", alpha = 0.2) +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 0.5) +
  geom_ribbon(stat = "density", aes(ymin = 0, ymax = ..density..), 
              fill = "orange", alpha = 0.7, 
              data = comparison_df_shuffled[comparison_df_shuffled$correlation_difference >= lower_bound & comparison_df_shuffled$correlation_difference <= upper_bound, ]) +
  labs(title = "Distribution of Correlation Differences",
       x = "Correlation Difference",
       y = "Density") +
  annotate("text", x = Inf, y = Inf, label = paste0("% greater than zero: ", round(percentage_greater_than_zero_shuffled, 2), "%"),
           hjust = 1.1, vjust = 1.1, size = 5, color = "black") +
  plot_aes
```

> Satisfaction with Life responses cannot distinguish Satisfaction with Life scores from Self-Acceptance scores (r = 0.624 verus 0.501, bootstrapped **p** = `r p_value`)

## Environmental Mastery

```{r}
# Extract actual values and predictions for both models
y_model1 <- df$`SWLS mean`
yhat_model1 <- model1_predictions$predictions$`embeddings$texts$\`SWLS-Text\`_SWLS mean_pred`
y_model2 <- df$`PWB environmental_mastery`
yhat_model2 <- model2_predictions$predictions$`embeddings$texts$\`SWLS-Text\`_PWB environmental_mastery_pred`

# Create data frame for Model 1
model1_df <- tibble::tibble(y_model1, yhat_model1)

# Break the association by shuffling the predicted values
model1_df_shuffled <- model1_df %>% mutate(yhat_model1 = sample(yhat_model1))

# Perform bootstrapping on the shuffled data
model1_boots_shuffled <- rsample::bootstraps(model1_df_shuffled, times = 10000, apparent = FALSE)
model1_boot_corrs_shuffled <- model1_boots_shuffled %>%
  mutate(corr_model1 = map(splits, corr_on_bootstrap))

model1_boot_distribution_shuffled <- model1_boot_corrs_shuffled %>%
  unnest(corr_model1) %>%
  select(corr_model1)

# Create data frame for Model 2
model2_df <- tibble::tibble(y_model2, yhat_model2)

# Break the association by shuffling the predicted values
model2_df_shuffled <- model2_df %>% mutate(yhat_model2 = sample(yhat_model2))

# Perform bootstrapping on the shuffled data
model2_boots_shuffled <- rsample::bootstraps(model2_df_shuffled, times = 10000, apparent = FALSE)
model2_boot_corrs_shuffled <- model2_boots_shuffled %>%
  mutate(corr_model2 = map(splits, corr_on_bootstrap))
model2_boot_distribution_shuffled <- model2_boot_corrs_shuffled %>%
  unnest(corr_model2) %>%
  select(corr_model2)

# Combine the distributions
comparison_df_shuffled <- tibble::tibble(
  correlation_difference = model1_boot_distribution_shuffled$corr_model1 - model2_boot_distribution_shuffled$corr_model2
)

# Calculate percentage of absolute differences greater than zero
percentage_greater_than_zero_shuffled <- mean(comparison_df_shuffled$correlation_difference > 0) * 100
p_value <- (100 - percentage_greater_than_zero_shuffled) / 100
```

```{r}
# Calculate the quantiles
lower_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.025)
upper_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.975)

# Calculate the mean difference for the vertical line
mean_diff <- mean(comparison_df_shuffled$correlation_difference)

# Create the plot
ggplot(comparison_df_shuffled, aes(x = correlation_difference)) +
  geom_density(color = "black", fill = "skyblue", alpha = 0.2) +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 0.5) +
  geom_ribbon(stat = "density", aes(ymin = 0, ymax = ..density..), 
              fill = "orange", alpha = 0.7, 
              data = comparison_df_shuffled[comparison_df_shuffled$correlation_difference >= lower_bound & comparison_df_shuffled$correlation_difference <= upper_bound, ]) +
  labs(title = "Distribution of Correlation Differences",
       x = "Correlation Difference",
       y = "Density") +
  annotate("text", x = Inf, y = Inf, label = paste0("% greater than zero: ", round(percentage_greater_than_zero_shuffled, 2), "%"),
           hjust = 1.1, vjust = 1.1, size = 5, color = "black") +
  plot_aes
```

> Satisfaction with life responses cannot distinguish satisfaction with life scores from Environmental Mastery scores (r = 0.624 verus 0.44, bootstrapped **p** = `r p_value`)

# Can Autonomy language assessments can Differentiate Autonomy from... {.tabset}

```{r}
# Load predictions for both models
model1_predictions = Autonomy_subscale
model2_predictions = Autonomy_subscale
```

## Self-Acceptance 

```{r}
# Extract actual values and predictions for both models
y_model1 <- df$`PWB autonomy`
yhat_model1 <- model1_predictions$predictions$`embeddings$texts$\`Autonomy-Text\`_PWB autonomy_pred`

y_model2 <- df$`PWB self_acceptance`
yhat_model2 <- model2_predictions$predictions$`embeddings$texts$\`Autonomy-Text\`_PWB self_acceptance_pred`

# Create data frame for Model 1
model1_df <- tibble::tibble(y_model1, yhat_model1)

# Break the association by shuffling the predicted values
model1_df_shuffled <- model1_df %>% mutate(yhat_model1 = sample(yhat_model1))

# Perform bootstrapping on the shuffled data
model1_boots_shuffled <- rsample::bootstraps(model1_df_shuffled, times = 10000, apparent = FALSE)
model1_boot_corrs_shuffled <- model1_boots_shuffled %>%
  mutate(corr_model1 = map(splits, corr_on_bootstrap))

model1_boot_distribution_shuffled <- model1_boot_corrs_shuffled %>%
  unnest(corr_model1) %>%
  select(corr_model1)

# Create data frame for Model 2
model2_df <- tibble::tibble(y_model2, yhat_model2)

# Break the association by shuffling the predicted values
model2_df_shuffled <- model2_df %>% mutate(yhat_model2 = sample(yhat_model2))

# Perform bootstrapping on the shuffled data
model2_boots_shuffled <- rsample::bootstraps(model2_df_shuffled, times = 10000, apparent = FALSE)
model2_boot_corrs_shuffled <- model2_boots_shuffled %>%
  mutate(corr_model2 = map(splits, corr_on_bootstrap))
model2_boot_distribution_shuffled <- model2_boot_corrs_shuffled %>%
  unnest(corr_model2) %>%
  select(corr_model2)

# Combine the distributions
comparison_df_shuffled <- tibble::tibble(
  correlation_difference = model1_boot_distribution_shuffled$corr_model1 - model2_boot_distribution_shuffled$corr_model2
)

# Calculate percentage of absolute differences greater than zero
percentage_greater_than_zero_shuffled <- mean(comparison_df_shuffled$correlation_difference > 0) * 100
p_value <- (100 - percentage_greater_than_zero_shuffled) / 100

```


```{r}
# Calculate the quantiles
lower_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.025)
upper_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.975)

# Calculate the mean difference for the vertical line
mean_diff <- mean(comparison_df_shuffled$correlation_difference)

# Create the plot
ggplot(comparison_df_shuffled, aes(x = correlation_difference)) +
  geom_density(color = "black", fill = "skyblue", alpha = 0.2) +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 0.5) +
  geom_ribbon(stat = "density", aes(ymin = 0, ymax = ..density..), 
              fill = "orange", alpha = 0.7, 
              data = comparison_df_shuffled[comparison_df_shuffled$correlation_difference >= lower_bound & comparison_df_shuffled$correlation_difference <= upper_bound, ]) +
  labs(title = "Distribution of Correlation Differences",
       x = "Correlation Difference",
       y = "Density") +
  annotate("text", x = Inf, y = Inf, label = paste0("% greater than zero: ", round(percentage_greater_than_zero_shuffled, 2), "%"),
           hjust = 1.1, vjust = 1.1, size = 5, color = "black") +
  plot_aes
```

> Autonomy responses cannot distinguish Autonomy scores from self-acceptance scores (r = 0.413 verus 0.175, bootstrapped **p** = `r p_value`)

## Positive Relationships 

```{r}
# Extract actual values and predictions for both models
y_model1 <- df$`PWB autonomy`
yhat_model1 <- model1_predictions$predictions$`embeddings$texts$\`Autonomy-Text\`_PWB autonomy_pred`
y_model2 <- df$`PWB positive_relations`
yhat_model2 <- model2_predictions$predictions$`embeddings$texts$\`Autonomy-Text\`_PWB positive_relations_pred`

# Create data frame for Model 1
model1_df <- tibble::tibble(y_model1, yhat_model1)

# Break the association by shuffling the predicted values
model1_df_shuffled <- model1_df %>% mutate(yhat_model1 = sample(yhat_model1))

# Perform bootstrapping on the shuffled data
model1_boots_shuffled <- rsample::bootstraps(model1_df_shuffled, times = 10000, apparent = FALSE)
model1_boot_corrs_shuffled <- model1_boots_shuffled %>%
  mutate(corr_model1 = map(splits, corr_on_bootstrap))

model1_boot_distribution_shuffled <- model1_boot_corrs_shuffled %>%
  unnest(corr_model1) %>%
  select(corr_model1)

# Create data frame for Model 2
model2_df <- tibble::tibble(y_model2, yhat_model2)

# Break the association by shuffling the predicted values
model2_df_shuffled <- model2_df %>% mutate(yhat_model2 = sample(yhat_model2))

# Perform bootstrapping on the shuffled data
model2_boots_shuffled <- rsample::bootstraps(model2_df_shuffled, times = 10000, apparent = FALSE)
model2_boot_corrs_shuffled <- model2_boots_shuffled %>%
  mutate(corr_model2 = map(splits, corr_on_bootstrap))
model2_boot_distribution_shuffled <- model2_boot_corrs_shuffled %>%
  unnest(corr_model2) %>%
  select(corr_model2)

# Combine the distributions
comparison_df_shuffled <- tibble::tibble(
  correlation_difference = model1_boot_distribution_shuffled$corr_model1 - model2_boot_distribution_shuffled$corr_model2
)

# Calculate percentage of absolute differences greater than zero
percentage_greater_than_zero_shuffled <- mean(comparison_df_shuffled$correlation_difference > 0) * 100
p_value <- (100 - percentage_greater_than_zero_shuffled) / 100
```


```{r}
# Calculate the quantiles
lower_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.025)
upper_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.975)

# Calculate the mean difference for the vertical line
mean_diff <- mean(comparison_df_shuffled$correlation_difference)

# Create the plot
ggplot(comparison_df_shuffled, aes(x = correlation_difference)) +
  geom_density(color = "black", fill = "skyblue", alpha = 0.2) +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 0.5) +
  geom_ribbon(stat = "density", aes(ymin = 0, ymax = ..density..), 
              fill = "orange", alpha = 0.7, 
              data = comparison_df_shuffled[comparison_df_shuffled$correlation_difference >= lower_bound & comparison_df_shuffled$correlation_difference <= upper_bound, ]) +
  labs(title = "Distribution of Correlation Differences",
       x = "Correlation Difference",
       y = "Density") +
  annotate("text", x = Inf, y = Inf, label = paste0("% greater than zero: ", round(percentage_greater_than_zero_shuffled, 2), "%"),
           hjust = 1.1, vjust = 1.1, size = 5, color = "black") +
  plot_aes
```

> Autonomy responses cannot distinguish Autonomy scores from Positive Relationship scores (r = 0.413 verus 0.019, bootstrapped **p** = `r p_value`)

## Environmental Mastery 

```{r}
# Extract actual values and predictions for both models
y_model1 <- df$`PWB autonomy`
yhat_model1 <- model1_predictions$predictions$`embeddings$texts$\`Autonomy-Text\`_PWB autonomy_pred`
y_model2 <- df$`PWB environmental_mastery`
yhat_model2 <- model2_predictions$predictions$`embeddings$texts$\`Autonomy-Text\`_PWB environmental_mastery_pred`

# Create data frame for Model 1
model1_df <- tibble::tibble(y_model1, yhat_model1)

# Break the association by shuffling the predicted values
model1_df_shuffled <- model1_df %>% mutate(yhat_model1 = sample(yhat_model1))

# Perform bootstrapping on the shuffled data
model1_boots_shuffled <- rsample::bootstraps(model1_df_shuffled, times = 10000, apparent = FALSE)
model1_boot_corrs_shuffled <- model1_boots_shuffled %>%
  mutate(corr_model1 = map(splits, corr_on_bootstrap))

model1_boot_distribution_shuffled <- model1_boot_corrs_shuffled %>%
  unnest(corr_model1) %>%
  select(corr_model1)

# Create data frame for Model 2
model2_df <- tibble::tibble(y_model2, yhat_model2)

# Break the association by shuffling the predicted values
model2_df_shuffled <- model2_df %>% mutate(yhat_model2 = sample(yhat_model2))

# Perform bootstrapping on the shuffled data
model2_boots_shuffled <- rsample::bootstraps(model2_df_shuffled, times = 10000, apparent = FALSE)
model2_boot_corrs_shuffled <- model2_boots_shuffled %>%
  mutate(corr_model2 = map(splits, corr_on_bootstrap))
model2_boot_distribution_shuffled <- model2_boot_corrs_shuffled %>%
  unnest(corr_model2) %>%
  select(corr_model2)

# Combine the distributions
comparison_df_shuffled <- tibble::tibble(
  correlation_difference = model1_boot_distribution_shuffled$corr_model1 - model2_boot_distribution_shuffled$corr_model2
)

# Calculate percentage of absolute differences greater than zero
percentage_greater_than_zero_shuffled <- mean(comparison_df_shuffled$correlation_difference > 0) * 100
p_value <- (100 - percentage_greater_than_zero_shuffled) / 100
```


```{r}
# Calculate the quantiles
lower_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.025)
upper_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.975)

# Calculate the mean difference for the vertical line
mean_diff <- mean(comparison_df_shuffled$correlation_difference)

# Create the plot
ggplot(comparison_df_shuffled, aes(x = correlation_difference)) +
  geom_density(color = "black", fill = "skyblue", alpha = 0.2) +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 0.5) +
  geom_ribbon(stat = "density", aes(ymin = 0, ymax = ..density..), 
              fill = "orange", alpha = 0.7, 
              data = comparison_df_shuffled[comparison_df_shuffled$correlation_difference >= lower_bound & comparison_df_shuffled$correlation_difference <= upper_bound, ]) +
  labs(title = "Distribution of Correlation Differences",
       x = "Correlation Difference",
       y = "Density") +
  annotate("text", x = Inf, y = Inf, label = paste0("% greater than zero: ", round(percentage_greater_than_zero_shuffled, 2), "%"),
           hjust = 1.1, vjust = 1.1, size = 5, color = "black") +
  plot_aes
```

> Autonomy responses cannot distinguish Autonomy scores from environmental mastery scores (r = 0.413 verus 0.17, bootstrapped **p** = `r p_value`)

## Personal Growth

```{r}
# Extract actual values and predictions for both models
y_model1 <- df$`PWB autonomy`
yhat_model1 <- model1_predictions$predictions$`embeddings$texts$\`Autonomy-Text\`_PWB autonomy_pred`
y_model2 <- df$`PWB personal_growth`
yhat_model2 <- model2_predictions$predictions$`embeddings$texts$\`Autonomy-Text\`_PWB personal_growth_pred`

# Create data frame for Model 1
model1_df <- tibble::tibble(y_model1, yhat_model1)

# Break the association by shuffling the predicted values
model1_df_shuffled <- model1_df %>% mutate(yhat_model1 = sample(yhat_model1))

# Perform bootstrapping on the shuffled data
model1_boots_shuffled <- rsample::bootstraps(model1_df_shuffled, times = 10000, apparent = FALSE)
model1_boot_corrs_shuffled <- model1_boots_shuffled %>%
  mutate(corr_model1 = map(splits, corr_on_bootstrap))

model1_boot_distribution_shuffled <- model1_boot_corrs_shuffled %>%
  unnest(corr_model1) %>%
  select(corr_model1)

# Create data frame for Model 2
model2_df <- tibble::tibble(y_model2, yhat_model2)

# Break the association by shuffling the predicted values
model2_df_shuffled <- model2_df %>% mutate(yhat_model2 = sample(yhat_model2))

# Perform bootstrapping on the shuffled data
model2_boots_shuffled <- rsample::bootstraps(model2_df_shuffled, times = 10000, apparent = FALSE)
model2_boot_corrs_shuffled <- model2_boots_shuffled %>%
  mutate(corr_model2 = map(splits, corr_on_bootstrap))
model2_boot_distribution_shuffled <- model2_boot_corrs_shuffled %>%
  unnest(corr_model2) %>%
  select(corr_model2)

# Combine the distributions
comparison_df_shuffled <- tibble::tibble(
  correlation_difference = model1_boot_distribution_shuffled$corr_model1 - model2_boot_distribution_shuffled$corr_model2
)

# Calculate percentage of absolute differences greater than zero
percentage_greater_than_zero_shuffled <- mean(comparison_df_shuffled$correlation_difference > 0) * 100
p_value <- (100 - percentage_greater_than_zero_shuffled) / 100
```


```{r}
# Calculate the quantiles
lower_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.025)
upper_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.975)

# Calculate the mean difference for the vertical line
mean_diff <- mean(comparison_df_shuffled$correlation_difference)

# Create the plot
ggplot(comparison_df_shuffled, aes(x = correlation_difference)) +
  geom_density(color = "black", fill = "skyblue", alpha = 0.2) +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 0.5) +
  geom_ribbon(stat = "density", aes(ymin = 0, ymax = ..density..), 
              fill = "orange", alpha = 0.7, 
              data = comparison_df_shuffled[comparison_df_shuffled$correlation_difference >= lower_bound & comparison_df_shuffled$correlation_difference <= upper_bound, ]) +
  labs(title = "Distribution of Correlation Differences",
       x = "Correlation Difference",
       y = "Density") +
  annotate("text", x = Inf, y = Inf, label = paste0("% greater than zero: ", round(percentage_greater_than_zero_shuffled, 2), "%"),
           hjust = 1.1, vjust = 1.1, size = 5, color = "black") +
  plot_aes
```

> Autonomy responses cannot distinguish Autonomy scores from personal growth scores (r = 0.413 verus 0.06, bootstrapped **p** = `r p_value`)

## Purpose

```{r}
# Extract actual values and predictions for both models
y_model1 <- df$`PWB autonomy`
yhat_model1 <- model1_predictions$predictions$`embeddings$texts$\`Autonomy-Text\`_PWB autonomy_pred`
y_model2 <- df$`PWB purpose`
yhat_model2 <- model2_predictions$predictions$`embeddings$texts$\`Autonomy-Text\`_PWB purpose_pred`

# Create data frame for Model 1
model1_df <- tibble::tibble(y_model1, yhat_model1)

# Break the association by shuffling the predicted values
model1_df_shuffled <- model1_df %>% mutate(yhat_model1 = sample(yhat_model1))

# Perform bootstrapping on the shuffled data
model1_boots_shuffled <- rsample::bootstraps(model1_df_shuffled, times = 10000, apparent = FALSE)
model1_boot_corrs_shuffled <- model1_boots_shuffled %>%
  mutate(corr_model1 = map(splits, corr_on_bootstrap))

model1_boot_distribution_shuffled <- model1_boot_corrs_shuffled %>%
  unnest(corr_model1) %>%
  select(corr_model1)

# Create data frame for Model 2
model2_df <- tibble::tibble(y_model2, yhat_model2)

# Break the association by shuffling the predicted values
model2_df_shuffled <- model2_df %>% mutate(yhat_model2 = sample(yhat_model2))

# Perform bootstrapping on the shuffled data
model2_boots_shuffled <- rsample::bootstraps(model2_df_shuffled, times = 10000, apparent = FALSE)
model2_boot_corrs_shuffled <- model2_boots_shuffled %>%
  mutate(corr_model2 = map(splits, corr_on_bootstrap))
model2_boot_distribution_shuffled <- model2_boot_corrs_shuffled %>%
  unnest(corr_model2) %>%
  select(corr_model2)

# Combine the distributions
comparison_df_shuffled <- tibble::tibble(
  correlation_difference = model1_boot_distribution_shuffled$corr_model1 - model2_boot_distribution_shuffled$corr_model2
)

# Calculate percentage of absolute differences greater than zero
percentage_greater_than_zero_shuffled <- mean(comparison_df_shuffled$correlation_difference > 0) * 100
p_value <- (100 - percentage_greater_than_zero_shuffled) / 100
```


```{r}
# Calculate the quantiles
lower_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.025)
upper_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.975)

# Calculate the mean difference for the vertical line
mean_diff <- mean(comparison_df_shuffled$correlation_difference)

# Create the plot
ggplot(comparison_df_shuffled, aes(x = correlation_difference)) +
  geom_density(color = "black", fill = "skyblue", alpha = 0.2) +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 0.5) +
  geom_ribbon(stat = "density", aes(ymin = 0, ymax = ..density..), 
              fill = "orange", alpha = 0.7, 
              data = comparison_df_shuffled[comparison_df_shuffled$correlation_difference >= lower_bound & comparison_df_shuffled$correlation_difference <= upper_bound, ]) +
  labs(title = "Distribution of Correlation Differences",
       x = "Correlation Difference",
       y = "Density") +
  annotate("text", x = Inf, y = Inf, label = paste0("% greater than zero: ", round(percentage_greater_than_zero_shuffled, 2), "%"),
           hjust = 1.1, vjust = 1.1, size = 5, color = "black") +
  plot_aes
```

> Autonomy responses cannot distinguish Autonomy scores from purpose in life scores (r = 0.413 verus 0.032, bootstrapped **p** = `r p_value`)

## Psychological Well-being

```{r}
# Extract actual values and predictions for both models
y_model1 <- df$`PWB autonomy`
yhat_model1 <- model1_predictions$predictions$`embeddings$texts$\`Autonomy-Text\`_PWB autonomy_pred`
y_model2 <- df$`PWB mean`
yhat_model2 <- model2_predictions$predictions$`embeddings$texts$\`Autonomy-Text\`_PWB mean_pred`

# Create data frame for Model 1
model1_df <- tibble::tibble(y_model1, yhat_model1)

# Break the association by shuffling the predicted values
model1_df_shuffled <- model1_df %>% mutate(yhat_model1 = sample(yhat_model1))

# Perform bootstrapping on the shuffled data
model1_boots_shuffled <- rsample::bootstraps(model1_df_shuffled, times = 10000, apparent = FALSE)
model1_boot_corrs_shuffled <- model1_boots_shuffled %>%
  mutate(corr_model1 = map(splits, corr_on_bootstrap))

model1_boot_distribution_shuffled <- model1_boot_corrs_shuffled %>%
  unnest(corr_model1) %>%
  select(corr_model1)

# Create data frame for Model 2
model2_df <- tibble::tibble(y_model2, yhat_model2)

# Break the association by shuffling the predicted values
model2_df_shuffled <- model2_df %>% mutate(yhat_model2 = sample(yhat_model2))

# Perform bootstrapping on the shuffled data
model2_boots_shuffled <- rsample::bootstraps(model2_df_shuffled, times = 10000, apparent = FALSE)
model2_boot_corrs_shuffled <- model2_boots_shuffled %>%
  mutate(corr_model2 = map(splits, corr_on_bootstrap))
model2_boot_distribution_shuffled <- model2_boot_corrs_shuffled %>%
  unnest(corr_model2) %>%
  select(corr_model2)

# Combine the distributions
comparison_df_shuffled <- tibble::tibble(
  correlation_difference = model1_boot_distribution_shuffled$corr_model1 - model2_boot_distribution_shuffled$corr_model2
)

# Calculate percentage of absolute differences greater than zero
percentage_greater_than_zero_shuffled <- mean(comparison_df_shuffled$correlation_difference > 0) * 100
p_value <- (100 - percentage_greater_than_zero_shuffled) / 100
```

```{r}
# Calculate the quantiles
lower_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.025)
upper_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.975)

# Calculate the mean difference for the vertical line
mean_diff <- mean(comparison_df_shuffled$correlation_difference)

# Create the plot
ggplot(comparison_df_shuffled, aes(x = correlation_difference)) +
  geom_density(color = "black", fill = "skyblue", alpha = 0.2) +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 0.5) +
  geom_ribbon(stat = "density", aes(ymin = 0, ymax = ..density..), 
              fill = "orange", alpha = 0.7, 
              data = comparison_df_shuffled[comparison_df_shuffled$correlation_difference >= lower_bound & comparison_df_shuffled$correlation_difference <= upper_bound, ]) +
  labs(title = "Distribution of Correlation Differences",
       x = "Correlation Difference",
       y = "Density") +
  annotate("text", x = Inf, y = Inf, label = paste0("% greater than zero: ", round(percentage_greater_than_zero_shuffled, 2), "%"),
           hjust = 1.1, vjust = 1.1, size = 5, color = "black") +
  plot_aes
```

> Autonomy responses cannot distinguish Autonomy scores from Psychological Well-being scores (r = 0.413 verus 0.106, bootstrapped **p** = `r p_value`)

## Satisfaction with Life

```{r}
# Extract actual values and predictions for both models
y_model1 <- df$`PWB autonomy`
yhat_model1 <- model1_predictions$predictions$`embeddings$texts$\`Autonomy-Text\`_PWB autonomy_pred`
y_model2 <- df$`SWLS mean`
yhat_model2 <- model2_predictions$predictions$`embeddings$texts$\`Autonomy-Text\`_SWLS mean_pred`

# Create data frame for Model 1
model1_df <- tibble::tibble(y_model1, yhat_model1)

# Break the association by shuffling the predicted values
model1_df_shuffled <- model1_df %>% mutate(yhat_model1 = sample(yhat_model1))

# Perform bootstrapping on the shuffled data
model1_boots_shuffled <- rsample::bootstraps(model1_df_shuffled, times = 10000, apparent = FALSE)
model1_boot_corrs_shuffled <- model1_boots_shuffled %>%
  mutate(corr_model1 = map(splits, corr_on_bootstrap))

model1_boot_distribution_shuffled <- model1_boot_corrs_shuffled %>%
  unnest(corr_model1) %>%
  select(corr_model1)

# Create data frame for Model 2
model2_df <- tibble::tibble(y_model2, yhat_model2)

# Break the association by shuffling the predicted values
model2_df_shuffled <- model2_df %>% mutate(yhat_model2 = sample(yhat_model2))

# Perform bootstrapping on the shuffled data
model2_boots_shuffled <- rsample::bootstraps(model2_df_shuffled, times = 10000, apparent = FALSE)
model2_boot_corrs_shuffled <- model2_boots_shuffled %>%
  mutate(corr_model2 = map(splits, corr_on_bootstrap))
model2_boot_distribution_shuffled <- model2_boot_corrs_shuffled %>%
  unnest(corr_model2) %>%
  select(corr_model2)

# Combine the distributions
comparison_df_shuffled <- tibble::tibble(
  correlation_difference = model1_boot_distribution_shuffled$corr_model1 - model2_boot_distribution_shuffled$corr_model2
)

# Calculate percentage of absolute differences greater than zero
percentage_greater_than_zero_shuffled <- mean(comparison_df_shuffled$correlation_difference > 0) * 100
p_value <- (100 - percentage_greater_than_zero_shuffled) / 100
```

```{r}
# Calculate the quantiles
lower_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.025)
upper_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.975)

# Calculate the mean difference for the vertical line
mean_diff <- mean(comparison_df_shuffled$correlation_difference)

# Create the plot
ggplot(comparison_df_shuffled, aes(x = correlation_difference)) +
  geom_density(color = "black", fill = "skyblue", alpha = 0.2) +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 0.5) +
  geom_ribbon(stat = "density", aes(ymin = 0, ymax = ..density..), 
              fill = "orange", alpha = 0.7, 
              data = comparison_df_shuffled[comparison_df_shuffled$correlation_difference >= lower_bound & comparison_df_shuffled$correlation_difference <= upper_bound, ]) +
  labs(title = "Distribution of Correlation Differences",
       x = "Correlation Difference",
       y = "Density") +
  annotate("text", x = Inf, y = Inf, label = paste0("% greater than zero: ", round(percentage_greater_than_zero_shuffled, 2), "%"),
           hjust = 1.1, vjust = 1.1, size = 5, color = "black") +
  plot_aes
```

> Autonomy responses can marginally distinguish Autonomy scores from Satisfaction with Life scores (r = 0.413 verus 0.207, bootstrapped **p** = `r p_value`)

# Are the two models' correlations significantly different {.tabset}

```{r}
model1_predictions = SWLS_subscale
model2_predictions = Autonomy_subscale
```


## Psychological Well-being

```{r}
# Extract actual values and predictions for both models
y_model1 <- df$`PWB mean`
yhat_model1 <- model1_predictions$predictions$`embeddings$texts$\`SWLS-Text\`_PWB mean_pred`
y_model2 <- df$`PWB mean`
yhat_model2 <- model2_predictions$predictions$`embeddings$texts$\`Autonomy-Text\`_PWB mean_pred`

# Create data frame for Model 1
model1_df <- tibble::tibble(y_model1, yhat_model1)

# Break the association by shuffling the predicted values
model1_df_shuffled <- model1_df %>% mutate(yhat_model1 = sample(yhat_model1))

# Perform bootstrapping on the shuffled data
model1_boots_shuffled <- rsample::bootstraps(model1_df_shuffled, times = 10000, apparent = FALSE)
model1_boot_corrs_shuffled <- model1_boots_shuffled %>%
  mutate(corr_model1 = map(splits, corr_on_bootstrap))

model1_boot_distribution_shuffled <- model1_boot_corrs_shuffled %>%
  unnest(corr_model1) %>%
  select(corr_model1)

# Create data frame for Model 2
model2_df <- tibble::tibble(y_model2, yhat_model2)

# Break the association by shuffling the predicted values
model2_df_shuffled <- model2_df %>% mutate(yhat_model2 = sample(yhat_model2))

# Perform bootstrapping on the shuffled data
model2_boots_shuffled <- rsample::bootstraps(model2_df_shuffled, times = 10000, apparent = FALSE)
model2_boot_corrs_shuffled <- model2_boots_shuffled %>%
  mutate(corr_model2 = map(splits, corr_on_bootstrap))
model2_boot_distribution_shuffled <- model2_boot_corrs_shuffled %>%
  unnest(corr_model2) %>%
  select(corr_model2)

# Combine the distributions
comparison_df_shuffled <- tibble::tibble(
  correlation_difference = model1_boot_distribution_shuffled$corr_model1 -  model2_boot_distribution_shuffled$corr_model2
)

# Calculate percentage of absolute differences greater than zero
percentage_greater_than_zero_shuffled <- mean(comparison_df_shuffled$correlation_difference > 0) * 100
p_value <- (100 - percentage_greater_than_zero_shuffled) / 100

```

```{r}
# Calculate the quantiles
lower_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.025)
upper_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.975)

# Calculate the mean difference for the vertical line
mean_diff <- mean(comparison_df_shuffled$correlation_difference)

# Create the plot
ggplot(comparison_df_shuffled, aes(x = correlation_difference)) +
  geom_density(color = "black", fill = "skyblue", alpha = 0.2) +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 0.5) +
  geom_ribbon(stat = "density", aes(ymin = 0, ymax = ..density..), 
              fill = "orange", alpha = 0.7, 
              data = comparison_df_shuffled[comparison_df_shuffled$correlation_difference >= lower_bound & comparison_df_shuffled$correlation_difference <= upper_bound, ]) +
  labs(title = "Distribution of Correlation Differences",
       x = "Correlation Difference",
       y = "Density") +
  annotate("text", x = Inf, y = Inf, label = paste0("% greater than zero: ", round(percentage_greater_than_zero_shuffled, 2), "%"),
           hjust = 1.1, vjust = 1.1, size = 5, color = "black") +
  plot_aes
```

> Satisfaction with life responses are not signifcantly different from Autonomy correlations when predictiing psychological well-being (r = 0.403 vs. 0.106, bootstrapped **p** = `r p_value`)

## Autonomy

```{r}
# Extract actual values and predictions for both models
y_model1 <- df$`PWB autonomy`
yhat_model1 <- model1_predictions$predictions$`embeddings$texts$\`SWLS-Text\`_PWB autonomy_pred`
y_model2 <- df$`PWB autonomy`
yhat_model2 <- model2_predictions$predictions$`embeddings$texts$\`Autonomy-Text\`_PWB autonomy_pred`

# Create data frame for Model 1
model1_df <- tibble::tibble(y_model1, yhat_model1)

# Break the association by shuffling the predicted values
model1_df_shuffled <- model1_df %>% mutate(yhat_model1 = sample(yhat_model1))

# Perform bootstrapping on the shuffled data
model1_boots_shuffled <- rsample::bootstraps(model1_df_shuffled, times = 10000, apparent = FALSE)
model1_boot_corrs_shuffled <- model1_boots_shuffled %>%
  mutate(corr_model1 = map(splits, corr_on_bootstrap))

model1_boot_distribution_shuffled <- model1_boot_corrs_shuffled %>%
  unnest(corr_model1) %>%
  select(corr_model1)

# Create data frame for Model 2
model2_df <- tibble::tibble(y_model2, yhat_model2)

# Break the association by shuffling the predicted values
model2_df_shuffled <- model2_df %>% mutate(yhat_model2 = sample(yhat_model2))

# Perform bootstrapping on the shuffled data
model2_boots_shuffled <- rsample::bootstraps(model2_df_shuffled, times = 10000, apparent = FALSE)
model2_boot_corrs_shuffled <- model2_boots_shuffled %>%
  mutate(corr_model2 = map(splits, corr_on_bootstrap))
model2_boot_distribution_shuffled <- model2_boot_corrs_shuffled %>%
  unnest(corr_model2) %>%
  select(corr_model2)

# Combine the distributions
comparison_df_shuffled <- tibble::tibble(
  correlation_difference = model1_boot_distribution_shuffled$corr_model1 - model2_boot_distribution_shuffled$corr_model2
)

# Calculate percentage of absolute differences greater than zero
percentage_greater_than_zero_shuffled <- mean(comparison_df_shuffled$correlation_difference > 0) * 100
p_value <- (100 - percentage_greater_than_zero_shuffled) / 100
```


```{r}
# Calculate the quantiles
lower_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.025)
upper_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.975)

# Calculate the mean difference for the vertical line
mean_diff <- mean(comparison_df_shuffled$correlation_difference)

# Create the plot
ggplot(comparison_df_shuffled, aes(x = correlation_difference)) +
  geom_density(color = "black", fill = "skyblue", alpha = 0.2) +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 0.5) +
  geom_ribbon(stat = "density", aes(ymin = 0, ymax = ..density..), 
              fill = "orange", alpha = 0.7, 
              data = comparison_df_shuffled[comparison_df_shuffled$correlation_difference >= lower_bound & comparison_df_shuffled$correlation_difference <= upper_bound, ]) +
  labs(title = "Distribution of Correlation Differences",
       x = "Correlation Difference",
       y = "Density") +
  annotate("text", x = Inf, y = Inf, label = paste0("% greater than zero: ", round(percentage_greater_than_zero_shuffled, 2), "%"),
           hjust = 1.1, vjust = 1.1, size = 5, color = "black") +
  plot_aes
```

> Satisfaction with life responses are not signifcantly different from Autonomy correlations when predictiing autonomy scores (r = 0.131 vs. 0.413, bootstrapped **p** = `r p_value`)

## Personal Growth 

```{r}
# Extract actual values and predictions for both models
y_model1 <- df$`PWB personal_growth`
yhat_model1 <- model1_predictions$predictions$`embeddings$texts$\`SWLS-Text\`_PWB personal_growth_pred`
y_model2 <- df$`PWB personal_growth`
yhat_model2 <- model2_predictions$predictions$`embeddings$texts$\`Autonomy-Text\`_PWB personal_growth_pred`

# Create data frame for Model 1
model1_df <- tibble::tibble(y_model1, yhat_model1)

# Break the association by shuffling the predicted values
model1_df_shuffled <- model1_df %>% mutate(yhat_model1 = sample(yhat_model1))

# Perform bootstrapping on the shuffled data
model1_boots_shuffled <- rsample::bootstraps(model1_df_shuffled, times = 10000, apparent = FALSE)
model1_boot_corrs_shuffled <- model1_boots_shuffled %>%
  mutate(corr_model1 = map(splits, corr_on_bootstrap))

model1_boot_distribution_shuffled <- model1_boot_corrs_shuffled %>%
  unnest(corr_model1) %>%
  select(corr_model1)

# Create data frame for Model 2
model2_df <- tibble::tibble(y_model2, yhat_model2)

# Break the association by shuffling the predicted values
model2_df_shuffled <- model2_df %>% mutate(yhat_model2 = sample(yhat_model2))

# Perform bootstrapping on the shuffled data
model2_boots_shuffled <- rsample::bootstraps(model2_df_shuffled, times = 10000, apparent = FALSE)
model2_boot_corrs_shuffled <- model2_boots_shuffled %>%
  mutate(corr_model2 = map(splits, corr_on_bootstrap))
model2_boot_distribution_shuffled <- model2_boot_corrs_shuffled %>%
  unnest(corr_model2) %>%
  select(corr_model2)

# Combine the distributions
comparison_df_shuffled <- tibble::tibble(
  correlation_difference = model1_boot_distribution_shuffled$corr_model1 - model2_boot_distribution_shuffled$corr_model2
)

# Calculate percentage of absolute differences greater than zero
percentage_greater_than_zero_shuffled <- mean(comparison_df_shuffled$correlation_difference > 0) * 100
p_value <- (100 - percentage_greater_than_zero_shuffled) / 100
```

```{r}
# Calculate the quantiles
lower_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.025)
upper_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.975)

# Calculate the mean difference for the vertical line
mean_diff <- mean(comparison_df_shuffled$correlation_difference)

# Create the plot
ggplot(comparison_df_shuffled, aes(x = correlation_difference)) +
  geom_density(color = "black", fill = "skyblue", alpha = 0.2) +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 0.5) +
  geom_ribbon(stat = "density", aes(ymin = 0, ymax = ..density..), 
              fill = "orange", alpha = 0.7, 
              data = comparison_df_shuffled[comparison_df_shuffled$correlation_difference >= lower_bound & comparison_df_shuffled$correlation_difference <= upper_bound, ]) +
  labs(title = "Distribution of Correlation Differences",
       x = "Correlation Difference",
       y = "Density") +
  annotate("text", x = Inf, y = Inf, label = paste0("% greater than zero: ", round(percentage_greater_than_zero_shuffled, 2), "%"),
           hjust = 1.1, vjust = 1.1, size = 5, color = "black") +
  plot_aes
```

> Satisfaction with life responses are not signifcantly different from Autonomy correlations when predictiing personal growth scores (r = 0.117 vs. 0.06, bootstrapped **p** = `r p_value`)

## Positive Relationships 

```{r}
# Extract actual values and predictions for both models
y_model1 <- df$`PWB positive_relations`
yhat_model1 <- model1_predictions$predictions$`embeddings$texts$\`SWLS-Text\`_PWB positive_relations_pred`
y_model2 <- df$`PWB positive_relations`
yhat_model2 <- model2_predictions$predictions$`embeddings$texts$\`Autonomy-Text\`_PWB positive_relations_pred`

# Create data frame for Model 1
model1_df <- tibble::tibble(y_model1, yhat_model1)

# Break the association by shuffling the predicted values
model1_df_shuffled <- model1_df %>% mutate(yhat_model1 = sample(yhat_model1))

# Perform bootstrapping on the shuffled data
model1_boots_shuffled <- rsample::bootstraps(model1_df_shuffled, times = 10000, apparent = FALSE)
model1_boot_corrs_shuffled <- model1_boots_shuffled %>%
  mutate(corr_model1 = map(splits, corr_on_bootstrap))

model1_boot_distribution_shuffled <- model1_boot_corrs_shuffled %>%
  unnest(corr_model1) %>%
  select(corr_model1)

# Create data frame for Model 2
model2_df <- tibble::tibble(y_model2, yhat_model2)

# Break the association by shuffling the predicted values
model2_df_shuffled <- model2_df %>% mutate(yhat_model2 = sample(yhat_model2))

# Perform bootstrapping on the shuffled data
model2_boots_shuffled <- rsample::bootstraps(model2_df_shuffled, times = 10000, apparent = FALSE)
model2_boot_corrs_shuffled <- model2_boots_shuffled %>%
  mutate(corr_model2 = map(splits, corr_on_bootstrap))
model2_boot_distribution_shuffled <- model2_boot_corrs_shuffled %>%
  unnest(corr_model2) %>%
  select(corr_model2)

# Combine the distributions
comparison_df_shuffled <- tibble::tibble(
  correlation_difference = model1_boot_distribution_shuffled$corr_model1 - model2_boot_distribution_shuffled$corr_model2
)

# Calculate percentage of absolute differences greater than zero
percentage_greater_than_zero_shuffled <- mean(comparison_df_shuffled$correlation_difference > 0) * 100
p_value <- (100 - percentage_greater_than_zero_shuffled) / 100
```



```{r}
# Calculate the quantiles
lower_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.025)
upper_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.975)

# Calculate the mean difference for the vertical line
mean_diff <- mean(comparison_df_shuffled$correlation_difference)

# Create the plot
ggplot(comparison_df_shuffled, aes(x = correlation_difference)) +
  geom_density(color = "black", fill = "skyblue", alpha = 0.2) +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 0.5) +
  geom_ribbon(stat = "density", aes(ymin = 0, ymax = ..density..), 
              fill = "orange", alpha = 0.7, 
              data = comparison_df_shuffled[comparison_df_shuffled$correlation_difference >= lower_bound & comparison_df_shuffled$correlation_difference <= upper_bound, ]) +
  labs(title = "Distribution of Correlation Differences",
       x = "Correlation Difference",
       y = "Density") +
  annotate("text", x = Inf, y = Inf, label = paste0("% greater than zero: ", round(percentage_greater_than_zero_shuffled, 2), "%"),
           hjust = 1.1, vjust = 1.1, size = 5, color = "black") +
  plot_aes
```

> Satisfaction with life responses are not signifcantly different from Autonomy correlations when predictiing positive relationship scores (r = 0.153 vs. 0.019, bootstrapped **p** = `r p_value`)

## Purpose

```{r}
# Extract actual values and predictions for both models
y_model1 <- df$`PWB purpose`
yhat_model1 <- model1_predictions$predictions$`embeddings$texts$\`SWLS-Text\`_PWB purpose_pred`
y_model2 <- df$`PWB purpose`
yhat_model2 <- model2_predictions$predictions$`embeddings$texts$\`Autonomy-Text\`_PWB purpose_pred`

# Create data frame for Model 1
model1_df <- tibble::tibble(y_model1, yhat_model1)

# Break the association by shuffling the predicted values
model1_df_shuffled <- model1_df %>% mutate(yhat_model1 = sample(yhat_model1))

# Perform bootstrapping on the shuffled data
model1_boots_shuffled <- rsample::bootstraps(model1_df_shuffled, times = 10000, apparent = FALSE)
model1_boot_corrs_shuffled <- model1_boots_shuffled %>%
  mutate(corr_model1 = map(splits, corr_on_bootstrap))

model1_boot_distribution_shuffled <- model1_boot_corrs_shuffled %>%
  unnest(corr_model1) %>%
  select(corr_model1)

# Create data frame for Model 2
model2_df <- tibble::tibble(y_model2, yhat_model2)

# Break the association by shuffling the predicted values
model2_df_shuffled <- model2_df %>% mutate(yhat_model2 = sample(yhat_model2))

# Perform bootstrapping on the shuffled data
model2_boots_shuffled <- rsample::bootstraps(model2_df_shuffled, times = 10000, apparent = FALSE)
model2_boot_corrs_shuffled <- model2_boots_shuffled %>%
  mutate(corr_model2 = map(splits, corr_on_bootstrap))
model2_boot_distribution_shuffled <- model2_boot_corrs_shuffled %>%
  unnest(corr_model2) %>%
  select(corr_model2)

# Combine the distributions
comparison_df_shuffled <- tibble::tibble(
  correlation_difference = model1_boot_distribution_shuffled$corr_model1 - model2_boot_distribution_shuffled$corr_model2
)

# Calculate percentage of absolute differences greater than zero
percentage_greater_than_zero_shuffled <- mean(comparison_df_shuffled$correlation_difference > 0) * 100
p_value <- (100 - percentage_greater_than_zero_shuffled) / 100
```



```{r}
# Calculate the quantiles
lower_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.025)
upper_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.975)

# Calculate the mean difference for the vertical line
mean_diff <- mean(comparison_df_shuffled$correlation_difference)

# Create the plot
ggplot(comparison_df_shuffled, aes(x = correlation_difference)) +
  geom_density(color = "black", fill = "skyblue", alpha = 0.2) +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 0.5) +
  geom_ribbon(stat = "density", aes(ymin = 0, ymax = ..density..), 
              fill = "orange", alpha = 0.7, 
              data = comparison_df_shuffled[comparison_df_shuffled$correlation_difference >= lower_bound & comparison_df_shuffled$correlation_difference <= upper_bound, ]) +
  labs(title = "Distribution of Correlation Differences",
       x = "Correlation Difference",
       y = "Density") +
  annotate("text", x = Inf, y = Inf, label = paste0("% greater than zero: ", round(percentage_greater_than_zero_shuffled, 2), "%"),
           hjust = 1.1, vjust = 1.1, size = 5, color = "black") +
  plot_aes
```

> Satisfaction with life responses are not signifcantly different from Autonomy correlations when predictiing purpose in life scores (r = 0.224 vs. -0.032, bootstrapped **p** = `r p_value`)

## Self-Acceptance

```{r}
# Extract actual values and predictions for both models
y_model1 <- df$`PWB self_acceptance`
yhat_model1 <- model1_predictions$predictions$`embeddings$texts$\`SWLS-Text\`_PWB self_acceptance_pred`
y_model2 <- df$`PWB self_acceptance`
yhat_model2 <- model2_predictions$predictions$`embeddings$texts$\`Autonomy-Text\`_PWB self_acceptance_pred`

# Create data frame for Model 1
model1_df <- tibble::tibble(y_model1, yhat_model1)

# Break the association by shuffling the predicted values
model1_df_shuffled <- model1_df %>% mutate(yhat_model1 = sample(yhat_model1))

# Perform bootstrapping on the shuffled data
model1_boots_shuffled <- rsample::bootstraps(model1_df_shuffled, times = 10000, apparent = FALSE)
model1_boot_corrs_shuffled <- model1_boots_shuffled %>%
  mutate(corr_model1 = map(splits, corr_on_bootstrap))

model1_boot_distribution_shuffled <- model1_boot_corrs_shuffled %>%
  unnest(corr_model1) %>%
  select(corr_model1)

# Create data frame for Model 2
model2_df <- tibble::tibble(y_model2, yhat_model2)

# Break the association by shuffling the predicted values
model2_df_shuffled <- model2_df %>% mutate(yhat_model2 = sample(yhat_model2))

# Perform bootstrapping on the shuffled data
model2_boots_shuffled <- rsample::bootstraps(model2_df_shuffled, times = 10000, apparent = FALSE)
model2_boot_corrs_shuffled <- model2_boots_shuffled %>%
  mutate(corr_model2 = map(splits, corr_on_bootstrap))
model2_boot_distribution_shuffled <- model2_boot_corrs_shuffled %>%
  unnest(corr_model2) %>%
  select(corr_model2)

# Combine the distributions
comparison_df_shuffled <- tibble::tibble(
  correlation_difference = model1_boot_distribution_shuffled$corr_model1 - model2_boot_distribution_shuffled$corr_model2
)

# Calculate percentage of absolute differences greater than zero
percentage_greater_than_zero_shuffled <- mean(comparison_df_shuffled$correlation_difference > 0) * 100
p_value <- (100 - percentage_greater_than_zero_shuffled) / 100
```



```{r}
# Calculate the quantiles
lower_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.025)
upper_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.975)

# Calculate the mean difference for the vertical line
mean_diff <- mean(comparison_df_shuffled$correlation_difference)

# Create the plot
ggplot(comparison_df_shuffled, aes(x = correlation_difference)) +
  geom_density(color = "black", fill = "skyblue", alpha = 0.2) +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 0.5) +
  geom_ribbon(stat = "density", aes(ymin = 0, ymax = ..density..), 
              fill = "orange", alpha = 0.7, 
              data = comparison_df_shuffled[comparison_df_shuffled$correlation_difference >= lower_bound & comparison_df_shuffled$correlation_difference <= upper_bound, ]) +
  labs(title = "Distribution of Correlation Differences",
       x = "Correlation Difference",
       y = "Density") +
  annotate("text", x = Inf, y = Inf, label = paste0("% greater than zero: ", round(percentage_greater_than_zero_shuffled, 2), "%"),
           hjust = 1.1, vjust = 1.1, size = 5, color = "black") +
  plot_aes
```

> Satisfaction with life responses are not signifcantly different from Autonomy correlations when predictiing self-acceptance scores (r = 0.501 vs. 0.175, bootstrapped **p**  = `r p_value`)

## Environmental Mastery

```{r}
# Extract actual values and predictions for both models
y_model1 <- df$`PWB environmental_mastery`
yhat_model1 <- model1_predictions$predictions$`embeddings$texts$\`SWLS-Text\`_PWB environmental_mastery_pred`
y_model2 <- df$`PWB environmental_mastery`
yhat_model2 <- model2_predictions$predictions$`embeddings$texts$\`Autonomy-Text\`_PWB environmental_mastery_pred`

# Create data frame for Model 1
model1_df <- tibble::tibble(y_model1, yhat_model1)

# Break the association by shuffling the predicted values
model1_df_shuffled <- model1_df %>% mutate(yhat_model1 = sample(yhat_model1))

# Perform bootstrapping on the shuffled data
model1_boots_shuffled <- rsample::bootstraps(model1_df_shuffled, times = 10000, apparent = FALSE)
model1_boot_corrs_shuffled <- model1_boots_shuffled %>%
  mutate(corr_model1 = map(splits, corr_on_bootstrap))

model1_boot_distribution_shuffled <- model1_boot_corrs_shuffled %>%
  unnest(corr_model1) %>%
  select(corr_model1)

# Create data frame for Model 2
model2_df <- tibble::tibble(y_model2, yhat_model2)

# Break the association by shuffling the predicted values
model2_df_shuffled <- model2_df %>% mutate(yhat_model2 = sample(yhat_model2))

# Perform bootstrapping on the shuffled data
model2_boots_shuffled <- rsample::bootstraps(model2_df_shuffled, times = 10000, apparent = FALSE)
model2_boot_corrs_shuffled <- model2_boots_shuffled %>%
  mutate(corr_model2 = map(splits, corr_on_bootstrap))
model2_boot_distribution_shuffled <- model2_boot_corrs_shuffled %>%
  unnest(corr_model2) %>%
  select(corr_model2)

# Combine the distributions
comparison_df_shuffled <- tibble::tibble(
  correlation_difference = model1_boot_distribution_shuffled$corr_model1 - model2_boot_distribution_shuffled$corr_model2
)

# Calculate percentage of absolute differences greater than zero
percentage_greater_than_zero_shuffled <- mean(comparison_df_shuffled$correlation_difference > 0) * 100
p_value <- (100 - percentage_greater_than_zero_shuffled) / 100

```

```{r}
# Calculate the quantiles
lower_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.025)
upper_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.975)

# Calculate the mean difference for the vertical line
mean_diff <- mean(comparison_df_shuffled$correlation_difference)

# Create the plot
ggplot(comparison_df_shuffled, aes(x = correlation_difference)) +
  geom_density(color = "black", fill = "skyblue", alpha = 0.2) +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 0.5) +
  geom_ribbon(stat = "density", aes(ymin = 0, ymax = ..density..), 
              fill = "orange", alpha = 0.7, 
              data = comparison_df_shuffled[comparison_df_shuffled$correlation_difference >= lower_bound & comparison_df_shuffled$correlation_difference <= upper_bound, ]) +
  labs(title = "Distribution of Correlation Differences",
       x = "Correlation Difference",
       y = "Density") +
  annotate("text", x = Inf, y = Inf, label = paste0("% greater than zero: ", round(percentage_greater_than_zero_shuffled, 2), "%"),
           hjust = 1.1, vjust = 1.1, size = 5, color = "black") +
  plot_aes
```

> Satisfaction with life responses are not signifcantly different from Autonomy correlations when predicting environmental mastery scores (r = 0.44 vs. 0.17, bootstrapped **p** = `r p_value`)

## Satisfaction with life 


```{r}
# Extract actual values and predictions for both models
y_model1 <- df$`SWLS mean`
yhat_model1 <- model1_predictions$predictions$`embeddings$texts$\`SWLS-Text\`_SWLS mean_pred`
y_model2 <- df$`SWLS mean`
yhat_model2 <- model2_predictions$predictions$`embeddings$texts$\`Autonomy-Text\`_SWLS mean_pred`

# Create data frame for Model 1
model1_df <- tibble::tibble(y_model1, yhat_model1)

# Break the association by shuffling the predicted values
model1_df_shuffled <- model1_df %>% mutate(yhat_model1 = sample(yhat_model1))

# Perform bootstrapping on the shuffled data
model1_boots_shuffled <- rsample::bootstraps(model1_df_shuffled, times = 10000, apparent = FALSE)
model1_boot_corrs_shuffled <- model1_boots_shuffled %>%
  mutate(corr_model1 = map(splits, corr_on_bootstrap))

model1_boot_distribution_shuffled <- model1_boot_corrs_shuffled %>%
  unnest(corr_model1) %>%
  select(corr_model1)

# Create data frame for Model 2
model2_df <- tibble::tibble(y_model2, yhat_model2)

# Break the association by shuffling the predicted values
model2_df_shuffled <- model2_df %>% mutate(yhat_model2 = sample(yhat_model2))

# Perform bootstrapping on the shuffled data
model2_boots_shuffled <- rsample::bootstraps(model2_df_shuffled, times = 10000, apparent = FALSE)
model2_boot_corrs_shuffled <- model2_boots_shuffled %>%
  mutate(corr_model2 = map(splits, corr_on_bootstrap))
model2_boot_distribution_shuffled <- model2_boot_corrs_shuffled %>%
  unnest(corr_model2) %>%
  select(corr_model2)

# Combine the distributions
comparison_df_shuffled <- tibble::tibble(
  correlation_difference = model1_boot_distribution_shuffled$corr_model1 - model2_boot_distribution_shuffled$corr_model2
)

# Calculate percentage of absolute differences greater than zero
percentage_greater_than_zero_shuffled <- mean(comparison_df_shuffled$correlation_difference > 0) * 100
p_value <- (100 - percentage_greater_than_zero_shuffled) / 100

```

```{r}
# Calculate the quantiles
lower_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.025)
upper_bound <- quantile(comparison_df_shuffled$correlation_difference, 0.975)

# Calculate the mean difference for the vertical line
mean_diff <- mean(comparison_df_shuffled$correlation_difference)

# Create the plot
ggplot(comparison_df_shuffled, aes(x = correlation_difference)) +
  geom_density(color = "black", fill = "skyblue", alpha = 0.2) +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 0.5) +
  geom_ribbon(stat = "density", aes(ymin = 0, ymax = ..density..), 
              fill = "orange", alpha = 0.7, 
              data = comparison_df_shuffled[comparison_df_shuffled$correlation_difference >= lower_bound & comparison_df_shuffled$correlation_difference <= upper_bound, ]) +
  labs(title = "Distribution of Correlation Differences",
       x = "Correlation Difference",
       y = "Density") +
  annotate("text", x = Inf, y = Inf, label = paste0("% greater than zero: ", round(percentage_greater_than_zero_shuffled, 2), "%"),
           hjust = 1.1, vjust = 1.1, size = 5, color = "black") +
  plot_aes
```

> Satisfaction with life responses are not signifcantly different from Autonomy correlations when predicting satisfaction with life scores (r = 0.624 vs. 0.207, **p** = `r p_value`)

# Supervised Dimension Projections {.tabset}

## Satisfaction with Life

```{r eval=FALSE, fig.height=7, fig.width=7, include=FALSE}
if (!file.exists("/Users/stevenmesquiti/Box Sync/CurrentProjects_Penn/LP2/well-being-prediction/models/Study3/SDP/SWLS_SWLS_SDP.RDS")) {
  # If the file doesn't exist, perform the analysis
 SWLS_SWLS_SDP <- textProjection(
    words = df$`SWLS-Text`,
    word_embeddings = embeddings$texts$`SWLS-Text`,
    word_types_embeddings = embeddings$word_types$`SWLS-Text`,
    x = df$`SWLS mean`)
  # Save the results in an RDS file
 
SWLS_SWLS <- textProjectionPlot(word_data = SWLS_SWLS_SDP, 
                                 min_freq_words_plot = 1,
                                 plot_n_word_extreme = 10, 
                                 plot_n_word_frequency = 5, 
                                 plot_n_words_middle = 5,
                                 y_axes = FALSE, 
                                 p_alpha = .05, 
                                 p_adjust_method = "fdr", 
                                 title_top = "Satisfaction with life\n (Supervised Dimension Projection)", 
                                 x_axes_label = "Low vs. High Satisfaction with life scores",
                                 y_axes_label = "", 
                                 bivariate_color_codes = c("#E07F6A", "#FFFFFF", "#85DB8E", 
                                                           "#E07F6A", "#EAEAEA", "#85DB8E", 
                                                           "#E07F6A", "#FFFFFF", "#85DB8E")) 
 
 
 
 
  saveRDS(SWLS_SWLS, "/Users/stevenmesquiti/Box Sync/CurrentProjects_Penn/LP2/well-being-prediction/models/Study3/SDP/SWLS_SWLS_SDP.RDS")
} else {
  # If the file exists, load the results from the RDS file
  SWLS_SWLS_SDP <- readRDS("/Users/stevenmesquiti/Box Sync/CurrentProjects_Penn/LP2/well-being-prediction/models/Study3/SDP/SWLS_SWLS_SDP.RDS")
}
# Filter the DataFrame based on your criteria
#stat sig words with freq > 10 


SWLS_SWLS_SDP$final_plot


ggsave("SWLS_SWLS_plot.png", plot = SWLS_SWLS$final_plot, width = 8, height = 6, dpi = 300)

```


```{r pressure, echo=FALSE, fig.cap="Autonomy Plot", out.width = '100%'}
knitr::include_graphics("SWLS_SWLS_plot.png")
```

## Autonomy

```{r eval=FALSE, fig.height=7, fig.width=7, include=FALSE}
if (!file.exists("/Users/stevenmesquiti/Box Sync/CurrentProjects_Penn/LP2/well-being-prediction/models/Study3/SDP/autonomy_autonomy_SDP.RDS")) {
  # If the file doesn't exist, perform the analysis
autonomy_autonomy_SDP <- textProjection(
    words = df$`Autonomy-Text`,
    word_embeddings = embeddings$texts$`Autonomy-Text`,
    word_types_embeddings = embeddings$word_types$`Autonomy-Text`,
    x = df$`PWB autonomy`)
  # Save the results in an RDS file


autonomy_autonomy <- textProjectionPlot(word_data = autonomy_autonomy_SDP, 
                                 min_freq_words_plot = 1,
                                 plot_n_word_extreme = 10, 
                                 plot_n_word_frequency = 5, 
                                 plot_n_words_middle = 5,
                                 y_axes = FALSE, 
                                 p_alpha = .05, 
                                 p_adjust_method = "fdr", 
                                 title_top = "Autonomy\n (Supervised Dimension Projection)", 
                                 x_axes_label = "Low vs. High Autonomy scores",
                                 y_axes_label = "", 
                                 bivariate_color_codes = c("#E07F6A", "#FFFFFF", "#85DB8E", 
                                                           "#E07F6A", "#EAEAEA", "#85DB8E", 
                                                           "#E07F6A", "#FFFFFF", "#85DB8E"))



  saveRDS(autonomy_autonomy, "/Users/stevenmesquiti/Box Sync/CurrentProjects_Penn/LP2/well-being-prediction/models/Study3/SDP/autonomy_autonomy_SDP.RDS")
} else {
  # If the file exists, load the results from the RDS file
  autonomy_autonomy_SDP <- readRDS("/Users/stevenmesquiti/Box Sync/CurrentProjects_Penn/LP2/well-being-prediction/models/Study3/SDP/autonomy_autonomy_SDP.RDS")
}
# Filter the DataFrame based on your criteria
#stat sig words with freq > 10 

ggsave("autonomy_autonomy_plot.png", plot = autonomy_autonomy$final_plot, width = 8, height = 6, dpi = 300)



#autonomy_autonomy_SDP = as.data.frame(autonomy_autonomy_SDP$word_data)
#filtered_df <- autonomy_autonomy_SDP %>%
 # filter(
  #  n > 1 &
    #p_values_dot.x < 0.1 &
   # complete.cases(.) &
  #!str_detect(words, paste(c("[.,?!]"), collapse = "|"))
#  )


#ggplot(filtered_df, aes(label = words, size = n, color = dot.x)) +
#  geom_text_wordcloud(,show.legend = T,inherit.aes = T,rm_outside = TRUE) +
#  scale_size_area(max_size = 40) + 
#  guides(size = guide_legend(title = "Frequency"),
#        color = guide_colorbar(title = "Predicted Score")) +
#   scale_color_gradient(low = "#c44536", high = "dodgerblue") +
 # plot_aes

```

```{r Autonomy SDP, echo=FALSE, fig.cap="", out.width='100%'}
knitr::include_graphics("autonomy_autonomy_plot.png")
```